**実践Common  lisp**
#+begin_src lisp
  (defmacro dbg (expr)
  `(let ((result ,expr))
     (format t "~&~S => ~S~%" ',expr result)
     result))
#+end_src

#+RESULTS:
: DBG

#+begin_src lisp :results output
  (defun hello-world ()
  (format t "Hello, world"))
  (dbg (hello-world))
#+end_src

#+RESULTS:
: Hello, world
: (HELLO-WORLD) => NIL

* 第3章 実践:簡単なデータベース
** CDの曲を管理する簡単なデータベースを作成する。
**** リスト
#+begin_src lisp
(list 1 2 3)
#+end_src

#+RESULTS:
| 1 | 2 | 3 |

**** 属性リスト
#+begin_src lisp
  (getf (list :a 1 :b 2) :b)
#+end_src

#+RESULTS:
: 2

*** CDを表す属性リストを返す関数
#+begin_src lisp
  (defun make-cd (title artist rating ripped) (list :title title :artist artist :rating rating :ripped ripped))
#+end_src

#+RESULTS:
: MAKE-CD

*** データベースを格納するダイナミック変数と、それを操作する関数

グローバル変数には耳当てをつける
#+begin_src lisp
(defvar *db* nil)
#+end_src

#+RESULTS:
: *DB*

Create
#+begin_src lisp
  (defun add-record (cd) (push cd *db*))
  
  (add-record (make-cd "Beyond The Binary" "星宮とと, SOZEN OTSUBO" 7 t))
  (add-record (make-cd "Sakanaction" "サカナクション" 10 t))
  (add-record (make-cd "懐かしい月は新しい月" "サカナクション" 10 t))
  (add-record (make-cd "条理加速の片隅、彼女と想像の中身に関する行方 EP" "gaburyu" 8 t))
  (add-record (make-cd "NewJeans 2nd EP 'Get Up'" "NewJeans" 7 t))
  (add-record (make-cd "Perfume The Best 'P Cubed'" "Perfume" 9 t))
#+end_src

#+RESULTS:
| :TITLE | Perfume The Best 'P Cubed'                 | :ARTIST | Perfume               | :RATING |  9 | :RIPPED | T |
| :TITLE | NewJeans 2nd EP 'Get Up'                   | :ARTIST | NewJeans              | :RATING |  7 | :RIPPED | T |
| :TITLE | 条理加速の片隅、彼女と想像の中身に関する行方 EP | :ARTIST | gaburyu               | :RATING |  8 | :RIPPED | T |
| :TITLE | 懐かしい月は新しい月                         | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction                                | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Beyond The Binary                          | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING |  7 | :RIPPED | T |
| :TITLE | 懐かしい月は新しい月                         | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction                                | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Beyond The Binary                          | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING |  7 | :RIPPED | T |

Read
#+begin_src lisp
  (defun dump-db ()
    (dolist (cd *db*)
      (format t "~{~a:~10t~a~%~}~%" cd)))
#+end_src

#+RESULTS:
: DUMP-DB

*** ユーザインタラクションを改善する
~force-output~ で、改行コードを待つことなくプロンプトが印字されるように保証する。
prompt-readの戻り値は最後のフォームの値、つまりREAD-LINEを呼び出した
戻り値であり、READ-LINEは読み込んだ文字列を値として返す。
#+begin_src lisp
  (defun prompt-read (prompt)
    (format *query-io* "~a: " prompt)
    (force-output *query-io*)
    (read-line *query-io*))
#+end_src

#+RESULTS:
: PROMPT-READ

値を順々に入力してもらいながら、新たなCDのレコードを生成する。

~PARSE-INTEGER~ 関数
- 文字列から数値が読み取れなかったり、数値でないゴミが混じっていると、エラーを通知するようになっている。
    ~:junk-allowed~ に ~t~ をセットすると、エラーを抑制できる。
- 数字を1つも見つけられなかったり、文字列全部がゴミだったら、
   ~nil~ を返すようになっている。 ~OR~ マクロを使って、nilなら0を返すようにする

~Y-OR-N-P~ 関数は、y, Y, n, Nで始まらない入力があるとユーザに再度入力を促す。
#+begin_src lisp
  (defun prompt-for-cd ()
    (make-cd
     (prompt-read "Title")
     (prompt-read "Artist")
     (or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)
     (y-or-n-p "Ripped [y/n]")
     ))
#+end_src

#+RESULTS:
: PROMPT-FOR-CD

仕上げに、 ~prompt-for-cd~ をユーザの気の済むまでループする関数でラップ
すれば、インタフェースの完成
#+begin_src lisp
  (defun add-cds ()
        (loop (add-record (prompt-for-cd))
              (if (not (y-or-n-p "Another? [y/n]: ")) (return))))
#+end_src

#+RESULTS:
: ADD-CDS

*** データベースの保存と読み出し

~WITH-OPEN-FILE~ マクロ
1. ファイルをオープンする
2. それを対応するストリーム変数に束縛する
3. 実行し終わったらファイルをクローズする
~WITH_STANDARD_IO_SYNTAX~ マクロ
- ~PRINT~ の動作に影響を与える可能性のある変数が、標準的な値に設定された
  状態になることを保証する

#+begin_src lisp
           (defun save-db (filename)
             (with-open-file (out filename
                                  :direction :output
                                  :if-exists :supersede)
               (with-standard-io-syntax
                 (print *db* out))))
#+end_src

#+RESULTS:
: SAVE-DB

#+begin_src lisp
(save-db "/Users/gomadoufu/ghq/github.com/gomadoufu/book-practical-common-lisp/my-cds.db")
#+end_src

#+RESULTS:
| :TITLE | Perfume The Best 'P Cubed'                 | :ARTIST | Perfume               | :RATING |  9 | :RIPPED | T |
| :TITLE | NewJeans 2nd EP 'Get Up'                   | :ARTIST | NewJeans              | :RATING |  7 | :RIPPED | T |
| :TITLE | 条理加速の片隅、彼女と想像の中身に関する行方 EP | :ARTIST | gaburyu               | :RATING |  8 | :RIPPED | T |
| :TITLE | 懐かしい月は新しい月                         | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction                                | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Beyond The Binary                          | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING |  7 | :RIPPED | T |
| :TITLE | 懐かしい月は新しい月                         | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction                                | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Beyond The Binary                          | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING |  7 | :RIPPED | T |

#+begin_src lisp
  (defun load-db (filename)
      (with-open-file (in filename)
        (with-standard-io-syntax
          (setf *db* (read in)))))
#+end_src

#+RESULTS:
: LOAD-DB

#+name: ファイルからロードする
#+begin_src lisp
(load-db "/Users/gomadoufu/ghq/github.com/gomadoufu/book-practical-common-lisp/my-cds.db")
#+end_src

#+RESULTS: ファイルからロードする
| :TITLE | Perfume The Best 'P Cubed'                | :ARTIST | Perfume               | :RATING |  9 | :RIPPED | T |
| :TITLE | NewJeans 2nd EP 'Get Up'                  | :ARTIST | NewJeans              | :RATING |  7 | :RIPPED | T |
| :TITLE | 条理加速の片隅、彼女と想像の中身に関する行方 EP | :ARTIST | gaburyu               | :RATING |  8 | :RIPPED | T |
| :TITLE | 懐かしい月は新しい月                         | :ARTIST | サカナクション          | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction                               | :ARTIST | サカナクション          | :RATING | 10 | :RIPPED | T |
| :TITLE | Beyond The Binary                         | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING |  7 | :RIPPED | T |

*** データベースにクエリを投げる
~REMOVE-IF-NOT~ 関数は述語とリストを引数にとって、述語を成立させる要素だけを含む新しいリストを返す。
~#'~ は、その後に来る識別子が変数ではなく関数であることを意味する。
#+begin_src lisp 
  (remove-if-not #'(lambda (cd) (equal (getf cd :artist) "サカナクション")) *db*)
#+end_src

#+RESULTS:
| :TITLE | 懐かしい月は新しい月 | :ARTIST | サカナクション | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction       | :ARTIST | サカナクション | :RATING | 10 | :RIPPED | T |

いろんなセレクタを引数に取る関数 select
#+begin_src lisp
  (defun select (selector-fn)
    (remove-if-not selector-fn *db*))
#+end_src

#+RESULTS:
: SELECT

アーティストセレクタ
#+begin_src lisp
  (defun artist-selector (artist)
    #'(lambda (cd) (equal (getf cd :artist) artist)))
#+end_src

#+RESULTS:
: ARTIST-SELECTOR

select関数の呼び出し
#+begin_src lisp
  (select (artist-selector "サカナクション"))
#+end_src

#+RESULTS:
| :TITLE | 懐かしい月は新しい月 | :ARTIST | サカナクション | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction       | :ARTIST | サカナクション | :RATING | 10 | :RIPPED | T |

汎用セレクタ関数生成機 where。
関数の引数リストの先頭に ~&key~ とつけることで、以降の引数を **キーワードパラメータ** にすることができる。
キーワードパラメータを使うと、引数を好きな順序で呼び出せるようになる。
また、引数に値を与えなくても関数が動作するようになる。値を与えなかった場合、そこは ~NIL~ になる。
さらに引数にはデフォルト引数を指定できるほか、値として与えた ~NIL~ と値が与えられなかった ~NIL~ を区別するための
パラメータ ~supplied-p~ を付与することもできるようになる。
#+begin_src lisp
  (defun where (&key title artist rating (ripped nil ripped-p))
    #'(lambda (cd)
        (and
         (if title (equal (getf cd :title) title) t)
         (if artist (equal (getf cd :artist) artist) t)
         (if rating (equal (getf cd :rating) rating) t)
         (if ripped-p (equal (getf cd :ripped) ripped) t))))
#+end_src

#+RESULTS:
: WHERE

*** 既存のレコードを更新する
レコードを更新する update 関数
#+begin_src lisp
  (defun update (selector-fn &key title artist rating (ripped nil ripped-p))
     (setf *db*
         (mapcar
          #'(lambda (row)
              (when (funcall selector-fn row)
                 (if title (setf (getf row :title) title))
                 (if artist (setf (getf row :artist) artist))
                 (if rating (setf (getf row :rating) rating))
                 (if ripped-p (setf (getf row :ripped) ripped)))
              row)
          *db*)))
#+end_src

#+RESULTS:
: UPDATE

#+begin_src lisp
  (update (where :artist "サカナクション") :rating 11)
#+end_src

#+RESULTS:
| :TITLE | Perfume The Best 'P Cubed'                | :ARTIST | Perfume               | :RATING |  9 | :RIPPED | T |
| :TITLE | NewJeans 2nd EP 'Get Up'                  | :ARTIST | NewJeans              | :RATING |  7 | :RIPPED | T |
| :TITLE | 条理加速の片隅、彼女と想像の中身に関する行方 EP | :ARTIST | gaburyu               | :RATING |  8 | :RIPPED | T |
| :TITLE | 懐かしい月は新しい月                         | :ARTIST | サカナクション          | :RATING | 11 | :RIPPED | T |
| :TITLE | Sakanaction                               | :ARTIST | サカナクション          | :RATING | 11 | :RIPPED | T |
| :TITLE | Beyond The Binary                         | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING |  7 | :RIPPED | T |

既存のレコードを削除する
#+begin_src lisp
    (defun delete-rows (selector-fn)
      (setf *db* (remove-if selector-fn *db*)))
#+end_src

#+RESULTS:
: DELETE-ROWS

*** ムダを排除して勝利を収める
マクロの話が出てきた！
- 「CやC++におけるテキストベースのマクロとCommon Lispのマクロとは、名前以外に本質的に何も共有しているものはない」
  - Rustのマクロとは似ているところがあるのかも
- 「Lispのマクロの本質は、自動的なコードジェネレータだ」
#+name: 初めてのマクロ
#+begin_src lisp :results output
  (defmacro backwards (expr) (reverse expr))
  (backwards ("hello, world" t format))
#+end_src

  #+RESULTS: 初めてのマクロ
  : hello, world

シングルクォートをつけると、Lispにそのフォームを評価することをやめさせることができる。
またバッククォートをつけると、クォートと同じように全体が評価されなくなるが、コンマが前に置かれた部分式だけは評価されるようになる。
#+begin_src lisp :results scalar
    (defun make-comparison-expr (field value)
      (list 'equal (list 'getf 'cd field value)))

    (defun make-comparison-expr (field value)
      `(equal (getf cd ,field) ,value))

    (make-comparison-expr :rating 10)
#+end_src

#+RESULTS:
: (EQUAL (GETF CD :RATING) 10)

~LOOPマクロ~ を使ってみよう
#+begin_src lisp
      (defun make-comparisons-list (fields)
        (loop while fields
              collecting (make-comparison-expr (pop fields) (pop fields))))
#+end_src

#+RESULTS:
: MAKE-COMPARISONS-LIST

whereをマクロで置き換える
- ~,@~ は、続く式を評価して、それを取り囲んでいるリストと繋ぎ合わせる。
- ~&rest~ があると関数やマクロは任意個数の引数を取れるようになり、それらのリストが単一の実引数になる。
#+begin_src lisp
    (defmacro where (&rest clauses)
      `#'(lambda (cd) (and ,@(make-comparisons-list clauses))))
#+end_src

#+RESULTS:
: WHERE

~MACROEXPAND-1~ を使うと、マクロを展開してチェックできる。
#+begin_src lisp :results scalar
  (macroexpand-1 '(where :title "Beyond The Binary" :ripped t))
#+end_src

#+RESULTS:
: #'(LAMBDA (CD)
:     (AND (EQUAL (GETF CD :TITLE) "Beyond The Binary")
:          (EQUAL (GETF CD :RIPPED) T)))
: T

whereマクロを実際に使ってみよう！
#+begin_src lisp
  (select (where :title "Beyond The Binary" :ripped t))
#+end_src

#+RESULTS:
| :TITLE | Beyond The Binary | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING | 7 | :RIPPED | T |

* 第4章 シンタックスとセマンティクス
** S式
以下のどちらかのこと。
- リスト
  - カッコで括られている
  - 空白で区切って、いくつでもS式を含められる
- アトム
  - リスト以外の、コメントをのぞいた全て。
** アトムの種類
- 数値
  - 整数、分数、浮動小数点数、複素数がある
- 文字列
  - ダブルクォートでくくる
  - バックスラッシュは次の文字をエスケープし、それが何であろうと文字列中に含まれるようにする。
    - ダブルクォートとバックスラッシュの2つだけは、文字列の中で必ずエスケープしなければならない。
- シンボル
  - ~FORMAT~ や ~hello-world~ や ~*db*~ といった、「名前」。
  - カッコやクォート類、カンマやコロン、バックスラッシュはエスケープすれば、シンボルの一部として使える
  - リストの読み取り機は、エスケープされていないシンボルを、全て大文字に変換する。
  - シンボルの命名規約
    - ハイフンがよく使われる
    - ダイナミック変数の先頭と末尾に ~*~ をつける
    - 定数の先頭と末尾に ~+~ をつける
    - 下位層の関数の先頭に ~%~ をつけるLisperもいるらしい
** LispフォームとしてのS式
アトムは2種類に分類できる
- シンボル
  - 変数の名前とみなされ、その変数の現在の値として評価される。
- それ以外
  - 自己評価型 (*self-evaluating*)のオブジェクト。
  - 数値や文字列など、評価器に渡すとそれ自身が帰ってくるもののこと。

シンボルも、変数の名前に代入すれば自己評価型になる。
~T~ や ~NIL~ はこの形式で定義されている。
キーワード引数で使われる **キーワードシンボル** ~:symbol~ も、同じく自己評価型になるシンボルで、
その名前の定数が自動的に定義される。

正規のリストフォームは、すべてシンボルで始まり、
評価のされかたによって3種類に分けられる。
- 関数呼び出しフォーム
- マクロフォーム
- 特殊フォーム
** 特殊オペレータ
すべての操作を関数として定義できるわけではない。例えば関数では、 ~IF~ を定義できない。
なぜなら、通常の関数ならば評価は左・内側から始まってしまうから。
以下の ~IF~ がもし関数なら、 ~x~ が何であれ、常に yes no が表示され、それから ~IF~ の評価が始まってしまい、
期待する動作にならない。
#+begin_src lisp
  (if x (format t "yes") (format t "no"))
#+end_src
この問題を解決するため、Common Lispには関数ではできないことをするための **特殊オペレータ** が25個ある。
リストの先頭が特殊オペレータの名前だった場合、式の残りはその特殊オペレータのルールに従って評価される。
** マクロ
ユーザに対して、Lispのシンタックスを拡張する手段を提供するのがマクロ。
マクロは「S式を引数に取って、そのマクロフォームの代わりに評価されるLispフォームを返す関数」と考えることができる。
- マクロはコンパイル時に展開される。
- 評価器は、マクロがマクロ関数に渡る前にマクロフォームの要素を評価することはない。
  よって、マクロフォームはきちんとしたLispフォームでなくても良い。
- ループ構文はいつだってマクロだ。
** 真、偽、そして等しさ
*** 真偽値
Common Lispにおいては、 ~NIL~ だけが唯一の偽の値で、他のあらゆるものが真。
標準の真の値はシンボル ~T~ で、具体的な値を持たない ~非NIL~ として使われる。

~NIL~ はアトムでもありリストでもあり(Common Lispでこの特徴を持つのはNILだけ)、空リストを表すのにも使われる。
また、読取器は空リストを見ると ~NIL~ として読む。
~nil~ = ~()~ = ~'nil~ = '()
*** 同一性の判定
Common Lispには、等価性を判定する述語が型ごとに用意されている。
例えば数値の比較には ~=~ を使い、文字の比較には ~CHAR=~ を使う。

Lispオブジェクト全般に使える、等価性判定の総称的な述語が4つある
- EQ
  - シンボル用。
  - 「オブジェクト同一性」(object identity)を比較する。
  - ただし数や文字のオブジェクト同一性は、処理系でそれらの型がどのように実装されているかに依存する
  - 数値や文字になり得る値の比較には、 ~EQ~ を使うべきではない。
- EQL
  - シンボル・数値・文字用。
  - ~EQL~ は ~EQ~ と同じようにオブジェクト同一性を判定する述語だが、同じ数値や文字の値を表している同じクラスの
    同じオブジェクトは、常に等しいと判定されると保証されている
  - 色々なスタイルがあるが、この本では *比較には常に ~EQL~ を使う* 。
- EQUAL
  - なんでも用。直感的。
  - ~EQL~ より等価性の判定基準が甘く、異なるオブジェクトでも等しいとみなされる
  - 文字列や配列、パス名について、ぱっと見で等しそうなら真になる。
  - その他のデータ型については ~EQL~ を使って判定される。
- EQUALP
  - なんでも用。かなりざっくり判定。
  - ~EQUAL~ よりさらに判定基準が甘い。
  - 文字列は、大文字小文字の違いがあっても等しいとみなされる
  - 数値は、数学的に同じなら等しいとみなされる。 ~(equalp 1 1.0)~ は真。
  - ~EQUALP~ からなるリスト同士は ~EQUALP~ であり、 ~EQUAL~ からなる配列も ~EQUALP~ である
  - その他のデータ型については ~EQL~ を使って判定される。
** Lispコードの書式
インデントは、コードの構造を反映したものにする。
括弧を書き間違えると、自動フォーマットしたときにインデントがおかしくなるので、気づけるはず(とのこと)。
- 意味的に同じだが改行が必要な場合は、同じレベルのインデントにする
- 関数・マクロ・特殊フォームは、本体をスペース2つ分インデントする
- *閉じ括弧は、閉じようとするリストの最後の要素と同じ行に書くこと。*
- コメント 1~4つのセミコロンを使う
  - セミコロン4つはファイルヘッダ
  - セミコロン3つは意味段落で使う
  - セミコロン1つは、文末の1行コメント
* 第5章 関数
** 新しい関数の定義
関数は ~defun~ マクロを使って定義される。
#+begin_src lisp :eval no
      (defun name (parameter*)
        "省略可能なドキュメンテーション文字列"
        body-form*)
#+end_src

*name* には、どんなシンボルでも使える。
- 変換系の関数には、よく ~string->widget~ のような名前がつけられる
- スネークケースやキャメルケース・パスカルケースではなく、ハイフンを使ったケバブケースで命名する。
  
*parameter* のリストは、関数を呼ぶときに渡す引数を保持するのに使う変数を定義する。以下のように色々種類がある
- 必須パラメータ
- オプショナルパラメータ
- マルチプルパラメータ
- キーワードパラメータ

パラメータリストの後に続く文字列リテラルは、関数の目的を説明する *ドキュメント* になる。
この文字列は関数の名前と自動的に対応づけられ、後で ~DOCUMENTATION~ 関数で取り出すことができる。

*body-form* は任意の個数のLisp式で構成される。
これらは関数が呼び出されるときに順番に評価され、最後の式の値が関数の値として返される。
最後の値を戻り値にしたくないときには、 ~RETURN-FROM~ という特殊オペレータを使ってreturnすることもできる。
** 関数のパラメータリスト
*** 必須パラメータ
パラメータリストが単純に、変数の名前からなるリストの時、そのパラメータを *必須パラメータ* と呼ぶ。
関数が呼び出される時、必須パラメータには、対応する実引数が必要になる。
必須パラメータと実引数の数が合わないと、Lispはエラーを通知する。
*** オプショナルパラメータ
関数呼び出しをするときに、一部の引数は適当なデフォルト値にして、関数側ででうまくやってほしい場面がある。
オプショナルパラメータを使うと、細かい値を気にしない呼び出し元に対しては適当なデフォルト値にして、
そうでない呼び出し元からは特定の値を受け取れるようにできる。

オプショナルパラメータ付きの関数を定義するには、すべての必須パラメータの *後に、*
~&optional~ というシンボルを置き、その後にオプショナルパラメータの名前を続ける。
#+begin_src lisp
  (defun foo (a b &optional c d) (list a b c d))
#+end_src

#+RESULTS:
: FOO

この関数が呼ばれたとき、引数は最初に必須パラメータに束縛され、さらに引数が残っていたら、
その値はオプショナルパラメータに束縛される。引数が残っていなければ、オプショナルパラメータは ~NIL~ になる。

#+begin_src lisp :results output
  (dbg (foo 1 2))
#+end_src

#+RESULTS:
: [DEBUG] (FOO 1 2) => (1 2 NIL NIL)

#+begin_src lisp :results output
  (dbg (foo 1 2 3))
#+end_src

#+RESULTS:
: [DEBUG] (FOO 1 2 3) => (1 2 3 NIL)

#+begin_src lisp :results output
  (dbg (foo 1 2 3 4))
#+end_src

#+RESULTS:
: [DEBUG] (FOO 1 2 3 4) => (1 2 3 4)


~NIL~ 以外のデフォルト値を指定するには、パラメータの名前の代わりに、名前とデフォルト値からなるリストを指定する。
#+begin_src lisp
  (defun foo (a &optional (b 10)) (list a b))
#+end_src

#+RESULTS:
: FOO

#+begin_src lisp :results output
  (dbg (foo "hello"))
#+end_src

#+RESULTS:
: [DEBUG] (FOO "hello") => ("hello" 10)

#+begin_src lisp :results output
  (dbg (foo "hello" "world"))
#+end_src

#+RESULTS:
: [DEBUG] (FOO "hello" "world") => ("hello" "world")

デフォルト値を設定する式では、すでにパラメータリストに登場している値を参照できる。
例えば矩形を描画する関数を書いているとして、特に正方形を手軽に描画したいとすると、こんなふうに書ける。
#+begin_src lisp :eval no
  (defun make-rectangle (width &optional (height width)) ...)
#+end_src


パラメータを指定するリストのデフォルト値の式の後に追加の変数を設定すると、オプショナル引数の実引数が
デフォルト値なのかカスタムの値なのかを判定できる。
#+begin_src lisp
  (defun foo (a b &optional (c 3 c-supplied-p))
    (list a b c c-supplied-p))
#+end_src

#+RESULTS:
: FOO

この関数では、 ~c~ がカスタムの値なら ~c-supplied-p~ が真に、そうでなければ ~NIL~ に束縛される。
このように使う変数の名前は、実際のパラメータの名前に ~-supplied-p~ をつけたものにするのが慣例。
#+begin_src lisp :results output
  (dbg (foo 1 2))
#+end_src

#+RESULTS:
: [DEBUG] (FOO 1 2) => (1 2 3 NIL)

#+begin_src lisp :results output
  (dbg (foo 1 2 100))
#+end_src

#+RESULTS:
: [DEBUG] (FOO 1 2 100) => (1 2 100 T)

*** レストパラメータ
必須パラメータとオプショナルパラメータに割り当てた後の残りの引数を、
シンボル ~&rest~ の後ろのパラメータにまとめることができる。
これはレストパラメータと呼ばれ、この残りの引数はリストとしてまとめられる。
レストパラメータを使うと、可変長引数を実現できる。
#+begin_src lisp
  (defun my+ (&rest numbers)
  (if (null numbers)
      0
      (+ (car numbers) (apply #'my+ (cdr numbers)))))
  (dbg (my+ 1 2 3))
#+end_src

#+RESULTS:
: MY+

*** キーワードパラメータ
キーワードパラメータを使うと、オプショナルパラメータよりももっと柔軟に、指定した位置の引数にだけ値を渡すことができる。
関数にキーワードパラメータを設定するには、必須パラメータと ~&optional~ および ~&rest~ の各パラメータの後に、
 ~&key~ というシンボルと任意の数の識別子を、リストとしてまとめておく。
#+begin_src lisp :eval no
  (defun foo (&key a b c) (list a b c))
#+end_src

各キーワードパラメータは同じ名前のキーワードの直後の値に束縛される。もし与えられたキーワードに対応する実引数が
与えられなかったら、対応するパラメータにはデフォルト値が割り当てられる。
デフォルト値の指定方法まわりは、オプショナルパラメータと同様。 ~-supplied-p~ も使える。
#+begin_src lisp
  (defun foo (&key (a 0) (b 0 b-supplied-p) (c (+ a b)))
    (list a b c b-supplied-p))
#+end_src

#+RESULTS:
: FOO

#+begin_src lisp :results output
  (dbg (foo :a 1 :c 3))
#+end_src

#+RESULTS:
: [DEBUG] (FOO :A 1 :C 3) => (1 0 3 NIL)

#+begin_src lisp :results output
  (dbg (foo :a 1 :c 3 :b 2))
#+end_src

#+RESULTS:
: [DEBUG] (FOO :A 1 :C 3 :B 2) => (1 2 3 T)

** 関数の戻り値
デフォルトでは、関数の最後の式を評価した値が、その関数の戻り値になる。
アーリーリターンしたい時は、特殊オペレータ ~RETURN-FROM~ が使える。
~RETURN-FROM~ はブロックから抜けるためのもので、関数と直接関係があるわけではない。
#+begin_src lisp :eval no
  (defun foo (n)
    (dotimes (i 10)
      (dotimes (j 10)
        (when (> (* i j) n)
          (return-from foo (list i j)))))
#+end_src

** データとしての関数または高階関数
*** 関数オブジェクトの取得
Lispでは、関数はオブジェクトの一種でしかない。関数を ~DEFUN~ で定義する時には、実際には2つのことをやっている。
- 新しい関数オブジェクトの生成
- そのオブジェクトに名前をつけること

関数オブジェクトを得る仕組みは ~FUNCTION~ という特殊オペレータが提供する。
~FUNCTION~ は引数を1つ取り、引数の名前を持つ関数オブジェクトを返す。
#+begin_src lisp :results output
  (defun foo (x) (* 2 x))
  (dbg (function foo))
#+end_src

#+RESULTS:
: [DEBUG] #'FOO => #<FUNCTION FOO>

また、 ~#'~ と書くことで、 ~FUNCTION~ と同じ効果を得られる。
#+begin_src lisp
  #'foo
#+end_src

#+RESULTS:
: #<FUNCTION FOO>

*** 関数オブジェクトの起動
関数オブジェクトを手に入れたら、それを起動する必要がある。起動の仕方は2種類ある
- ~FUNCALL~
- ~APPLY~
両者は、呼び出す関数への引数の渡し方に違いがある。

**** FUNCALL
~FUNCALL~ は、渡す引数の個数が静的に判明しているときに使う。
#+begin_src lisp :results output
  (dbg (foo 2))
  (dbg (funcall #'foo 2))
#+end_src

#+RESULTS:
: [DEBUG] (FOO 2) => 4
: [DEBUG] (FUNCALL #'FOO 2) => 4

#+begin_src lisp :results output
  (defun plot (fn min max step)
    (loop for i from min to max by step do
      (loop repeat (funcall fn i) do (format t "*"))
      (format t "~%")))
  (plot #'exp 0 4 1/2)
#+end_src

#+RESULTS:
: *
: **
: ***
: *****
: ********
: *************
: *********************
: **********************************
: *******************************************************

**** APPLY
~FUNCALL~ は、引数リストが実行時にしかわからない場合には使いづらい。
そのような場合には、引数リストをそのまま渡せる ~APPLY~ を使う。
#+begin_src lisp :eval no
  (apply #'plot plot-data)
#+end_src

~APPLY~ は、適用される関数のとる引数が ~&optional~ なのか ~&rest~ なのか ~&key~ なのかは気にしない。
引数の数だけ気にする。

** 無名関数
いちいち新しい関数を定義するのが面倒な場合は、 ~LAMBDA~ 式を使って無名の関数を作れる。
#+begin_src lisp :eval no
  (lambda (parameters) body)
#+end_src
~LAMBDA~ は特別な構文なので、このフォームは仕様上、値として評価されることはない。
しかし歴史的な経緯から、特別な記号を何もつけずとも、全体がそのまま値として評価されてしまう。
よって ~LAMBDA~ を関数オブジェクトとして扱う場合に ~#'~ をつける派閥とつけない派閥がいる。本書では、常に ~#'~ をつけるとのこと。
#+begin_src lisp :results output
  (dbg (funcall #'(lambda (x y) (+ x y)) 2 3))
#+end_src

#+RESULTS:
: [DEBUG] (FUNCALL #'(LAMBDA (X Y) (+ X Y)) 2 3) => 5

関数を引数として別の関数に渡す必要があって、その渡す必要のある関数がインラインで書けるくらいシンプルな場合に、無名関数が活躍する。
#+begin_src lisp :results output
  (defun plot (fn min max step)
    (loop for i from min to max by step do
      (loop repeat (funcall fn i) do (format t "*"))
      (format t "~%")))
  
  (plot #'(lambda (x) (* 2 x)) 0 10 1)
#+end_src

~LAMBDA~ 式の重要な用途にクロージャの作成がある。
クロージャとは、それを作成した時点での環境の一部をキャプチャした関数のこと。

* 第6章 変数
** 変数の基礎
Common Lispの変数は *動的型付け* であり、かつ *強い型付け* である。

すべての値はオブジェクトへの参照であり、変数に新しい値を代入しても、変化するのはアドレスのみ。
ただし、もし変数が保持しているのがmutableなオブジェクトへの参照なら、その参照を使ってオブジェクトそのものを変更でき、
変更の結果は同じオブジェクトを参照しているすべてのコードから見えるようになる。

新しい変数を導入する方法の一つは、 ~DEFUN~ で関数を定義すること。
関数を定義すると、パラメータリストが引数を保持する変数の定義となる。
関数が呼ばれるたびに、Lispは実引数を保持するための新しい *束縛(binding)* を作る。束縛とは、変数の実行時における発現のこと。
ある一つの変数は、プログラムの実行中に異なる複数の束縛を持てる。


そのほかに、特殊オペレータ ~LET~ でも変数を導入できる。
#+begin_src lisp :eval no
 (let (variable*)
   body-form*)
#+end_src
~variable~ は変数の初期化フォームで、変数名とその初期値のリスト または ただの変数名(値は ~NIL~ になる) のどちらかがくる。

~LET~ フォームが評価されるときには、
1. まず初期値のフォームがすべて評価され、
2. 次に新しい束縛がつくられて初期化された後、
3. 本体のフォーム ~BODY-FORM~ が実行される。

関数のパラメータや LET の変数の *スコープ(scope)* は、変数を導入したフォームによって制限される。
関数を定義するフォームや ~LET~ フォームは、 *束縛フォーム(binding form)* と呼ばれている。
レキシカル変数とダイナミック変数とでは使っているスコープの仕組みが少し違うが、両方とも束縛フォームによってスコープが区切られている。

おなじ名前の変数を導入する束縛フォームを入れ子にすると、最も内側の変数の束縛が外側の束縛を *隠す(shadow)* 。

~LET~ の変種の ~LET*~ という束縛フォームもある。LETでは本体でしか変数の名前を使えないが、LET*では初期化フォーム内で、それより前の
初期化フォームに出てきた束縛を使うことができる。

** レキシカル変数とクロージャ
Common Lispでは、束縛フォームが導入する変数は、すべてデフォルトで *レキシカルなスコープを持つ* 。
また、レキシカルスコープと無名関数を組み合わせると、 ~クロージャ(closure：閉包)~ を実現できる。
以下の無名関数は、 ~LET~ の外から起動された場合でも、 ~count~ の値を利用することができる。
#+begin_src lisp :eval no
  (let ((count 0)) #'(lambda () (setf count (1+ count))))
#+end_src

ひとつのクロージャに複数の変数を閉じ込めることもできる
#+begin_src lisp :results output
  (defparameter *fn* (let ((count 0)) (list #'(lambda () (incf count)) #'(lambda () (decf count)) #'(lambda () count))))
  (dbg (funcall (car *fn*)))
  (dbg (funcall (car *fn*)))
  (dbg (funcall (car *fn*)))
  (dbg (funcall (cadr *fn*)))
#+end_src

#+RESULTS:
: [DEBUG] (FUNCALL (CAR *FN*)) => 1
: [DEBUG] (FUNCALL (CAR *FN*)) => 2
: [DEBUG] (FUNCALL (CAR *FN*)) => 3
: [DEBUG] (FUNCALL (CADR *FN*)) => 2

** ダイナミック変数。またの名をスペシャル変数
レキシカル変数も便利だが、グローバル変数にも理にかなった使い方がある。
Common Lispには *ダイナミック変数* が用意されている。

グローバルなスコープを持つ変数を作る方法は、 ~DEFVAR~ と ~DEFPARAMETER~ の2通りがある。
両方とも変数名と初期値、それから省略可能なドキュメンテーション文字列を取る。
#+begin_src lisp :eval no
  (defvar *count* 0 "製造済みの部品数")
  (defparameter *gap-tolerance* 0.001 "部品間の隙間の許容幅")
#+end_src
 ~DEFPARAMETER~ では評価されるたびに常に初期値を代入するが、 ~DEFVAR~ は変数が未定義だった場合のみ初期値を代入する。
 変数を定義するとき、その変数を使うソースコードを変更したとしても維持しておきたいデータには、 ~DEFVAR~ を使う。
 ソースコードに直接影響するようなパラメータなら、 ~DEFPARAMETER~ が適切。

 ダイナミック変数には、一般的なグローバル変数とは異なる性質がある。
 ダイナミック変数を ~LET~ フォームや関数のパラメータなどで束縛すると、その束縛フォームが続いている間は、
 グローバルな変数の束縛が束縛フォームの入り口で作られた束縛(ダイナミックな束縛)に置き換えられる。
 また、これはレキシカルな束縛とも違って、束縛フォームを実行している間に起動されるどんなコードからでも、
 このダイナミックな束縛を参照できる。
 #+begin_src lisp :eval no
   ; stuffはLETで作られた束縛を参照する
   ; さらに、letで束縛されている間に*standard-output*にアクセスするすべてのコードも、LETで作られた束縛を参照する
   (let ((*standard-output* *some-other-stream*))
     (stuff))
 #+end_src
 考え方としては、ダイナミック変数への束縛は変数の「束縛スタック」の一番上にプッシュされると思うとよい
 
** 定数
Common Lispでは定数はグローバルであり、 ~DEFCONSTANT~ によって定義される。
ダイナミック変数に対する ~*~ の命名規約と同じように、定数には ~+~ をつけることになっている。

** 代入
束縛をしたらできることは2つ。現在の値を得ることと、新しい値を設定すること。
現在の値を得るには、変数を参照するだけでいい。
束縛して新しい値を代入するには、 ~SETF~ マクロを使う。
#+begin_src lisp :eval no
  (setf x 10)
  (setf x 1 y 2 z 3) ;複数一気に束縛できる
  (setf x (setf y (random 10))) ;setfは代入した値を返す
#+end_src

** 一般化代入
Common Lispでは、配列やハッシュテーブル、リストといったどんなデータ構造への代入であっても、 ~SETF~ が使える。
#+begin_src lisp :eval no
  (setf x 10) ;値
  (setf (aref a 0) 10) ;配列
  (setf (gethash 'key hash) 10) ;ハッシュテーブル
  (setf (field o) 10) ;fieldという名前のスロット
#+end_src

** 束縛された値を変更する別のやり方
どんな代入も ~SETF~ で表現できるが、値を変更して再代入するような場合は、独自のオペレータにやらせるのが一般的。
たとえば、インクリメント・デクリメントをする ~INCF~, ~DECF~ など
#+begin_src lisp :eval no
  (incf x)
  (decf x)
  (incf x 10)
#+end_src
これらは *モディファイマクロ* と呼ばれる、 ~SETF~ の上に作られたマクロである。

モディファイマクロには他に ~PUSH~, ~POP~, ~PUSHNEW~, ~ROTATEF~, ~SHIFTF~ などがある。
~ROTATEF~ は、束縛と束縛とで値を入れ替える。要するにswapだ
#+begin_src lisp :results output
  (let ((a 10) (b 20))
    (princ a)
    (print b)
    (rotatef a b)
    (print a)
    (print b))
#+end_src

#+RESULTS:
: 10
: 20 
: 20 
: 10

~SHIFTF~ は、値をひとつ左にずらす。3番目の引数の値は2番目の引数に束縛され、2番目の引数の値は1番目の引数に束縛される。
フォーム全体として、1番目の引数を返す。

* 第7章 マクロ
マクロはLispに組み込まれた、言語を拡張できる機能。

** WHENとUNLESS
#+begin_src lisp :eval no
  (defmacro when (condition &rest body)
   `(if ,condition (progn ,@body)))

  (defmacro unless (condition &rest body)
   `(if (not ,condition) (progn ,@body)))
#+end_src

** DOLISTとDOTIMES
#+begin_src lisp :results output
  (dolist (x '(1 2 3)) (print x))
#+end_src

#+RESULTS:
: 
: 1 
: 2 
: 3

中断には ~RETURN~ が使える。
#+begin_src lisp :results output
  (dolist (x '(1 2 3)) (print x) (if (evenp x) (return)))
#+end_src

#+RESULTS:
: 
: 1 
: 2 

#+begin_src lisp :results output
  (dotimes (x 20)
      (dotimes (y 20)
        (format t "~3d " (* (1+ x) (1+ y))))
  (format t "~%"))
#+end_src

#+RESULTS:
#+begin_example
  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20 
  2   4   6   8  10  12  14  16  18  20  22  24  26  28  30  32  34  36  38  40 
  3   6   9  12  15  18  21  24  27  30  33  36  39  42  45  48  51  54  57  60 
  4   8  12  16  20  24  28  32  36  40  44  48  52  56  60  64  68  72  76  80 
  5  10  15  20  25  30  35  40  45  50  55  60  65  70  75  80  85  90  95 100 
  6  12  18  24  30  36  42  48  54  60  66  72  78  84  90  96 102 108 114 120 
  7  14  21  28  35  42  49  56  63  70  77  84  91  98 105 112 119 126 133 140 
  8  16  24  32  40  48  56  64  72  80  88  96 104 112 120 128 136 144 152 160 
  9  18  27  36  45  54  63  72  81  90  99 108 117 126 135 144 153 162 171 180 
 10  20  30  40  50  60  70  80  90 100 110 120 130 140 150 160 170 180 190 200 
 11  22  33  44  55  66  77  88  99 110 121 132 143 154 165 176 187 198 209 220 
 12  24  36  48  60  72  84  96 108 120 132 144 156 168 180 192 204 216 228 240 
 13  26  39  52  65  78  91 104 117 130 143 156 169 182 195 208 221 234 247 260 
 14  28  42  56  70  84  98 112 126 140 154 168 182 196 210 224 238 252 266 280 
 15  30  45  60  75  90 105 120 135 150 165 180 195 210 225 240 255 270 285 300 
 16  32  48  64  80  96 112 128 144 160 176 192 208 224 240 256 272 288 304 320 
 17  34  51  68  85 102 119 136 153 170 187 204 221 238 255 272 289 306 323 340 
 18  36  54  72  90 108 126 144 162 180 198 216 234 252 270 288 306 324 342 360 
 19  38  57  76  95 114 133 152 171 190 209 228 247 266 285 304 323 342 361 380 
 20  40  60  80 100 120 140 160 180 200 220 240 260 280 300 320 340 360 380 400 
#+end_example

** DO
ループの終了判定に任意の式を使いたい時は、より柔軟な ~DO~ ループが使える。
~DO~ では任意の数のループ変数を束縛でき、ループの各段階において値を変更する方法も利用者が完全に制御できる。
#+begin_src lisp :eval no
  (do ((変数1 初期値1 ステップ式1)
     (変数2 初期値2 ステップ式2)
     …)
    (終端テスト 結果式)
  ループの本体…)
#+end_src
以下のコードでは、 ~n~, ~cur~, ~next~ が変数で、 ~(= 10 n)~ がループを抜ける条件になっている。
#+begin_src lisp
  (do ((n 0 (1+ n))
       (cur 0 next)
       (next 1 (+ cur next)))
      ((= 10 n) cur))
#+end_src
混乱するけど、 ~DO~ ループには上記のように、ループの本体が全く要らない場合がある。引数だけで計算を終えている。


ループの本体を書くとこんな感じ。
#+begin_src lisp :results output
  (do ((n 0 (1+ n))
       (cur 0 next)
       (next 1 (+ cur next)))
      ((= 10 n) cur)
  (print cur))
#+end_src

#+RESULTS:
#+begin_example

0 
1 
1 
2 
3 
5 
8 
13 
21 
34 
#+end_example

引数リストを空にすることで、無限ループも書ける。
~DO~ の代わりに、 ~LOOP~ マクロを使うこともある。

* 第8章 マクロ：自分で定義しよう
マクロはあまりにうまく言語に統合されているので関数のように見えるが、マクロは関数とは全く異なるレベルの完全に違う抽象である。

**マクロを書くステップ**
1. マクロ呼び出しのサンプルを書き、その展開形を書く。またはその逆をやる
2. マクロ呼び出しのサンプルから展開形を生成するコードを書く。
3. マクロによる抽象化に漏れがないことを確認する。

**マクロを書く時の注意点**
- マクロを呼び出す時に出現するのと同じ順序で評価されるように、すべての部分フォームを配置すること。引数のパラメータなど。
- 部分フォームが一度だけ評価されるようにすること。展開形の中で引数のフォームを評価して、その値を変数で保持すると良い
- 展開形の中で使う変数の名前は、展開時に1度だけ ~GENSYM~ を使って作ること。

** DEFMACRO
マクロは ~DEFMACRO~ フォームで定義される
#+begin_src lisp :eval no
  (defmacro name (parameter*)
    "省略可能なドキュメンテーション文字列"
    body-form*)
#+end_src

* 第11章 コレクション
** ベクタ
シーケンスのサブタイプで、リストの兄弟。固定サイズと可変サイズがある。

*** VECTOR関数
固定サイズのベクタは ~VECTOR~ 関数で作ることができる。 ~VECTOR~ は任意個の引数をとり、
引数で与えた要素を含む固定サイズのベクタを新しく確保する。
#+begin_src lisp :results output
  (dbg (vector 1 2 3))
#+end_src

#+RESULTS:
: [DEBUG] (VECTOR 1 2 3) => #(1 2 3)

このように、ベクタのリテラル表記は ~#(...)~ となる。
ベクタのリテラルオブジェクトに変更を加えた場合の動作は定義されていないので、リテラル表記ではなく ~VECTOR~ 関数でベクタを生成するべき。

*** MAKE-ARRAY関数
~MAKE-ARRAY~ は ~VECTOR~ よりも汎用の関数で、固定サイズと可変サイズの両方のベクタを作れる。
引数として、配列の次元を表すリストを受け取る。
#+begin_src lisp
  (make-array 5 :initial-element nil)
#+end_src

#+RESULTS:
| NIL | NIL | NIL | NIL | NIL |

可変長のベクタを作るには、 ~fill-pointer~ 引数を渡す。
次の ~MAKE-ARRAY~ 呼び出しは5つのcapacityを持つが、フィルポインタが0のためlengthが空っぽであるように見える。
#+begin_src lisp :results output
  (dbg (make-array 5 :fill-pointer 0))
#+end_src

#+RESULTS:
: [DEBUG] (MAKE-ARRAY 5 :FILL-POINTER 0) => #()

可変ベクタの末尾に要素を追加するには、 ~VECTOR-PUSH~ を使う。これはフィルポインタの値をインクリメントして、追加した要素のインデックスを返す。
~VECTOR-POP~ は、最後に追加された要素を返し、フィルポインタの値をデクリメントする。

#+begin_src lisp :results output
  (defparameter *x* (make-array 5 :fill-pointer 0))

  (dbg (vector-push 'a *x*))
  (dbg (vector-push 'b *x*))
  (dbg (vector-push 'c *x*))
  (dbg *x*)
  (dbg (vector-pop *x*))
  (dbg (vector-pop *x*))
  (dbg (vector-pop *x*))
#+end_src

#+RESULTS:
: [DEBUG] (VECTOR-PUSH 'A *X*) => 0
: [DEBUG] (VECTOR-PUSH 'B *X*) => 1
: [DEBUG] (VECTOR-PUSH 'C *X*) => 2
: [DEBUG] *X* => #(A B C)
: [DEBUG] (VECTOR-POP *X*) => C
: [DEBUG] (VECTOR-POP *X*) => B
: [DEBUG] (VECTOR-POP *X*) => A


上限がない、capacityが自動で大きくなるようなベクタを作るには、 ~MAKE-ARRAY~ にキーワード引数 ~:adjustable~ を追加する。
可変ベクタに要素を追加するには、 ~VECTOR-PUSH-EXTEND~ を使う。

#+begin_src lisp :results output
  (defparameter *x* (make-array 1 :fill-pointer 0 :adjustable t))

  (dbg (vector-push-extend 'a *x*))
  (dbg (vector-push-extend 'b *x*))
  (dbg (vector-push-extend 'c *x*))
  
  (dbg *x*)
#+end_src

#+RESULTS:
: [DEBUG] (VECTOR-PUSH-EXTEND 'A *X*) => 0
: [DEBUG] (VECTOR-PUSH-EXTEND 'B *X*) => 1
: [DEBUG] (VECTOR-PUSH-EXTEND 'C *X*) => 2
: [DEBUG] *X* => #(A B C)

*** 特殊ベクタ
これまで出てきたベクタは任意の型のオブジェクトを持つことができる汎用のベクタだった。
Common Lispでは、要素の型をある特定の型に制限した ~特殊ベクタ~ を作ることもできる。

文字列は特殊ベクタの一種。 ~MAKE-ARRAY~ にキーワード引数 ~:element-type~ を与えるとベクタの要素の型指定が
できるが、ここに ~CHARACTER~ を指定すれば文字列になる。
#+begin_src lisp :results output
   (dbg (make-array 5 :fill-pointer 0 :adjustable t :element-type 'character))
#+end_src

#+RESULTS:
: [DEBUG] (MAKE-ARRAY 5 :FILL-POINTER 0 :ADJUSTABLE T :ELEMENT-TYPE 'CHARACTER) => ""
                        
*** シーケンスとしてのベクタ
シーケンス関数について。

長さを返す ~LENGTH~ と要素を取得する ~ELT~ (elementの略)
#+begin_src lisp :results output
  (defparameter *x* (vector 1 2 3))
  (defparameter *hello* "hello world")

  (dbg (length *x*))
  (dbg (length *hello*))

  (dbg (elt *x* 0))
  (dbg (elt *x* 1))
  (setf (elt *x* 0) 100)
  (dbg *x*)

  (dbg (elt *hello* 0))
  (setf (elt *hello* 0) #\H)
  (dbg *hello*)
#+end_src

#+RESULTS:
: [DEBUG] (LENGTH *X*) => 3
: [DEBUG] (LENGTH *HELLO*) => 11
: [DEBUG] (ELT *X* 0) => 1
: [DEBUG] (ELT *X* 1) => 2
: [DEBUG] *X* => #(100 2 3)
: [DEBUG] (ELT *HELLO* 0) => #\h
: [DEBUG] *HELLO* => "Hello world"

シーケンス反復関数
~COUNT~, ~FIND~, ~POSITION~, ~REMOVE~, ~SUBSTITUTE~
#+begin_src lisp :results output
  (dbg (count 1 #(1 2 1 2 3 1 2 3 4)))

  (dbg (remove 1 '(1 2 1 2 3 1 2 3 4)))
  (dbg (remove #\a "foobarbaz"))

  (dbg (substitute 10 1 #(1 2 1 2 3 1 2 3 4)))
  (dbg (substitute #\x #\b "foobarbaz"))

  (dbg (find 1 '(1 2 1 2 3 1 2 3 4)))  ; 値が見つかればその値を返す(tとして)

  (dbg (position 1 #(1 2 1 2 3 1 2 3 4)))
#+end_src

#+RESULTS:
: (COUNT 1 #(1 2 1 2 3 1 2 3 4)) => 3
: (REMOVE 1 '(1 2 1 2 3 1 2 3 4)) => (2 2 3 2 3 4)
: (REMOVE #\a "foobarbaz") => "foobrbz"
: (SUBSTITUTE 10 1 #(1 2 1 2 3 1 2 3 4)) => #(10 2 10 2 3 10 2 3 4)
: (SUBSTITUTE #\x #\b "foobarbaz") => "fooxarxaz"
: (FIND 1 '(1 2 1 2 3 1 2 3 4)) => 1
: (POSITION 1 #(1 2 1 2 3 1 2 3 4)) => 0

シーケンス反復関数には各種キーワード関数を指定することができる。
~:test~ ... パラメータで渡した値とシーケンスの要素との比較に使う2引数関数を指定する
~:key~ ... 実際のシーケンスの要素から、キーを取り出すための1引数関数
~:start~, ~:end~ ... シーケンス反復関数の適用範囲を制限する
~:from-end~ ... シーケンス関数の適用を逆順(末尾から)にする
~:count~ ... ~REMOVE~ と ~SUBSTITUTE~ の時、この操作を実行する上限数を表す。 ~NIL~ ならすべてを意味する。デフォルトで ~NIL~ 。
#+begin_src lisp :results output
  (dbg (count "foo" #("foo" "bar" "baz") :test #'string=)) ;テスト関数にstring=を指定
  (dbg (find 'a #((a 10) (b 20) (c 30) (a 100)) :key #'first)) ;シーケンスの要素のfirstに対してfind
  (dbg (find 'a #((a 10) (b 20) (c 30) (a 100)) :key #'first :from-end t)) ;さらに、逆順でfind
  (dbg (remove #\a "ababab" :count 2)) ;最大2個までremoveする
#+end_src

#+RESULTS:
: (COUNT "foo" #("foo" "bar" "baz") :TEST #'STRING=) => 1
: (FIND 'A #((A 10) (B 20) (C 30) (A 100)) :KEY #'FIRST) => (A 10)
: (FIND 'A #((A 10) (B 20) (C 30) (A 100)) :KEY #'FIRST :FROM-END T) => (A 100)
: (REMOVE #\a "ababab" :COUNT 2) => "bbab"


これらシーケンス反復関数それぞれについて、 ~<FUNCTION>-IF~ と ~<FUNCTION>-IF-NOT~ という高階関数の亜種が用意されている。
IFがついた方はテスト関数を受け取り、それが真を返す要素に対してのみ、countやfindやsubstituteを行う。
IF-NOTの方もテスト関数を受け取るが、それが偽を返す要素に対してのみ、countやfindやsubstituteを行う。
#+begin_src lisp :results output
  (dbg (count-if #'evenp #(1 2 3 4 5)))

  (dbg (position-if #'digit-char-p "abcd0001"))

  (dbg (remove-if-not #'(lambda (x) (char= (elt x 0) #\f)) #("foo" "bar" "baz" "foom")))
  ;; ("foo" "bar" "baz" "foom").filter(|x| x.first.is_char())
  ;; remove-if-not は、つまりFilterのこと。よく使う。
#+end_src

#+RESULTS:
: (COUNT-IF #'EVENP #(1 2 3 4 5)) => 2
: (POSITION-IF #'DIGIT-CHAR-P "abcd0001") => 4
: (REMOVE-IF-NOT #'(LAMBDA (X) (CHAR= (ELT X 0) #\f)) #("foo" "bar" "baz" "foom")) => #("foo"
:                                                                                       "foom")

*** ソートとマージ
シーケンスをソートする関数は ~SORT~ と ~STABLE-SORT~ の2種類ある。いずれも、シーケンスと述語の2つの引数を取る。
#+begin_src lisp :results output
  (dbg (sort (vector "foo" "bar" "baz") #'string<))
#+end_src

#+RESULTS:
: (SORT (VECTOR "foo" "bar" "baz") #'STRING<) => #("bar" "baz" "foo")

~STABLE-SORT~ は、述語によって等価だと判断された要素同士の順序が入れ替わらない。元の順序が保存される。

ソート関数は破壊的関数の代表例で、引数のシーケンスを変更してしまう。よって、引数を利用せずに返り値を利用すること。
#+begin_src lisp :eval no
  ;; (sort my-sequence #'string<) 🙅
  
  (setf my-sequence (sort my-sequence #'string<)) 🙆
#+end_src

~MERGE~ 関数は2つのシーケンスと述語をとり、2つのシーケンスを述語に照らしつつマージする。
第1引数には生成されるシーケンスの型を指定する。
#+begin_src lisp :results output
  (dbg (merge 'vector #(1 3 5) #(2 4 6) #'<))
  (dbg (merge 'list #(1 3 5) #(2 4 6) #'<))
#+end_src

#+RESULTS:
: (MERGE 'VECTOR #(1 3 5) #(2 4 6) #'<) => #(1 2 3 4 5 6)
: (MERGE 'LIST #(1 3 5) #(2 4 6) #'<) => (1 2 3 4 5 6)

*** 部分シーケンス操作
既存のシーケンスの部分シーケンスを操作するための関数がいくつかある。一番基本的なのは ~SUBSEQ~ 。
PythonやRustのスライスに似た感じ。
#+begin_src lisp :results output
  (dbg (subseq "foobarbaz" 3))
  (dbg (subseq "foobarbaz" 3 6))
#+end_src

#+RESULTS:
: (SUBSEQ "foobarbaz" 3) => "barbaz"
: (SUBSEQ "foobarbaz" 3 6) => "bar"

シーケンスの中から部分シーケンスを検索するには ~SEARCH~ 関数を使う。
#+begin_src lisp :results output
  (dbg (search "bar" "foobarbaz"))
#+end_src

#+RESULTS:
: (SEARCH "bar" "foobarbaz") => 3

*** シーケンス述語
シーケンス全体に適用して真偽を評価するための述語関数が4つある。
~EVERY~, ~SOME~, ~NOTANY~, ~NOTEVERY~.

いずれも第1引数が述語で、残りの引数がシーケンスになる。
第1引数の述語は、残りの引数であるシーケンスの数と同じ数の引数を取るものでなければならない。
シーケンスの要素を全て使い果たすか、全体の終了条件を満たすまで、述語にはシーケンスの要素が1つずつ渡される。

#+begin_src lisp :results output
  (dbg (every #'evenp #(1 2 3 4 5)))
  (dbg (some #'evenp #(1 2 3 4 5)))
  (dbg (notany #'evenp #(1 2 3 4 5)))
  (dbg (notevery #'evenp #(1 2 3 4 5)))
  (terpri)
  (dbg (every #'> #(1 2 3 4) #(5 4 3 2)))
  (dbg (some #'> #(1 2 3 4) #(5 4 3 2)))
  (dbg (notany #'> #(1 2 3 4) #(5 4 3 2)))
  (dbg (notevery #'> #(1 2 3 4) #(5 4 3 2)))
  #+end_src

  #+RESULTS:
  : (EVERY #'EVENP #(1 2 3 4 5)) => NIL
  : (SOME #'EVENP #(1 2 3 4 5)) => T
  : (NOTANY #'EVENP #(1 2 3 4 5)) => NIL
  : (NOTEVERY #'EVENP #(1 2 3 4 5)) => T
  : 
  : (EVERY #'> #(1 2 3 4) #(5 4 3 2)) => NIL
  : (SOME #'> #(1 2 3 4) #(5 4 3 2)) => T
  : (NOTANY #'> #(1 2 3 4) #(5 4 3 2)) => NIL
  : (NOTEVERY #'> #(1 2 3 4) #(5 4 3 2)) => T

*** シーケンスマッピング関数
~MAP~ は上記シーケンス述語関数に似ていて、N個の引数を取る関数とN個のシーケンスを受け取る。
しかし ~MAP~ は真偽値ではなく、シーケンスの各要素に関数を適用した結果を含む新しいシーケンスを返す。
~CONCATENATE~ や ~MERGE~ のように、どんな種類のシーケンスを作るのか指定する必要がある。
#+begin_src lisp :results output
  (dbg (map 'vector #'* #(1 2 3 4 5) #(10 9 8 7 6)))
#+end_src

#+RESULTS:
: (MAP 'VECTOR #'* #(1 2 3 4 5) #(10 9 8 7 6)) => #(10 18 24 28 30)

~MAP-INTO~ というのもあり、これは新しいシーケンスを生成するのではなく、第1引数として渡したシーケンスに値を設定する。

もちろん、 ~REDUCE~ もある。アキュムレータはキーワード引数 ~:initial-value~ で設定する。
#+begin_src lisp :results output
  (dbg (reduce #'+ #(1 2 3 4 5 6 7 8 9 10) :initial-value 45))
#+end_src

#+RESULTS:
: (REDUCE #'+ #(1 2 3 4 5 6 7 8 9 10) :INITIAL-VALUE 45) => 100

** ハッシュテーブル
引数なしの ~MAKE-HASH-TABLE~ は、キーの等価を ~EQL~ によって判定するタイプのハッシュテーブルを作成する。
これはキーとして文字列を使う場合には問題になる。 ~EQL~ では2つの文字列が同じ内容か判別できない。
キーワード引数 ~:test~ に シンボル ~EQUAL~ を渡すと、 ~EQUAL~ によって判定するタイプのハッシュテーブルを作成できる。

ハッシュテーブルの要素にアクセスするには ~GETHASH~ 関数を使う。
#+begin_src lisp :results output
  (defparameter *h* (make-hash-table))

  (dbg (gethash 'foo *h*))
  (dbg (setf (gethash 'foo *h*) 'quux))
  (dbg (gethash 'foo *h*))
  #+end_src

  #+RESULTS:
  : (GETHASH 'FOO *H*) => NIL
  : (SETF (GETHASH 'FOO *H*) 'QUUX) => QUUX
  : (GETHASH 'FOO *H*) => QUUX

~GETHASH~ は多値を返却する。多値を利用するための ~MULTIPLE-VALUE-BIND~ マクロが提供されている。
#+begin_src lisp :results output
  ;; 直前のコードブロックに依存
  (defun show-value (key hash-table)
    (multiple-value-bind (value present) (gethash key hash-table)
        (if present
              (format nil "Value ~a actually present." value)
              (format nil "Value ~a because key not found." value))))

  (setf (gethash 'bar *h*) nil) ;NILを設定

  (dbg (show-value 'foo *h*))
  (dbg (show-value 'bar *h*))
  (dbg (show-value 'baz *h*))
  #+end_src

  #+RESULTS:
  : (SHOW-VALUE 'FOO *H*) => "Value QUUX actually present."
  : (SHOW-VALUE 'BAR *H*) => "Value NIL actually present."
  : (SHOW-VALUE 'BAZ *H*) => "Value NIL because key not found."


~REMHASH~ 関数でキーと値のペアを削除できるほか、 ~CLRHASH~ でハッシュテーブルを空にできる。

*** ハッシュテーブル上の反復
~MAPHASH~ は ~MAP~ に似た関数で、関数とハッシュテーブルをとり、ハッシュテーブル内のキーと値の各ペアに対して関数を呼び出す。
#+begin_src lisp :results output
  (maphash #'(lambda (k v) (format t "key: ~a value: ~a~%" k v)) *h*)
#+end_src

#+RESULTS:
: KEY: FOO VALUE: QUUX
: KEY: BAR VALUE: NIL

#+begin_src lisp :results output
  (defparameter *t* (make-hash-table))

  (setf (gethash 'zero *t*) 0)
  (setf (gethash 'ten *t*) 10)
  (setf (gethash 'hundred *t*) 100)

  (maphash #'(lambda (k v) (format t "key: ~a value: ~a~%" k v)) *t*)

  (terpri)

  (maphash #'(lambda (k v) (when (< v 10) (remhash k *t*))) *t*)
  (maphash #'(lambda (k v) (format t "key: ~a value: ~a~%" k v)) *t*)
  #+end_src

#+RESULTS:
: key: ZERO value: 0
: key: TEN value: 10
: key: HUNDRED value: 100
: 
: key: TEN value: 10
: key: HUNDRED value: 100

* 第12章 リスト処理：やつらがLISPと呼ぶ理由
** 「リストなんてない」
#+begin_quote
リストを理解する手がかりは、そのほとんどがより基本的なデータ型のインスタンスであるオブジェクトの上に構築された幻想だと理解することにある。
#+end_quote

リストは単純なオブジェクト: コンスセルの上に構築されている。
~CONS~ は2つの引数をとり、それら2つの値を保持する新しいコンスセルを返す。コンスセルは括弧の中に2つの値がドットで区切られたものとして印字される。
#+begin_src lisp :results output
  (dbg (cons 1 2))
#+end_src

#+RESULTS:
: (CONS 1 2) => (1 . 2)

2つの値には ~CAR~ と ~CDR~ でアクセスする。これらには ~SETF~ できる。
#+begin_src lisp :results output
  (dbg (car (cons 1 2)))
  (dbg (cdr (cons 1 2)))
  (terpri)

  (defparameter *cons* (cons 1 2))
  (dbg (setf (car *cons*) 10))
  (dbg *cons*)
#+end_src

#+RESULTS:
: (CAR (CONS 1 2)) => 1
: (CDR (CONS 1 2)) => 2
: 
: (SETF (CAR *CONS*) 10) => 10
: *CONS* => (10 . 2)


ある値がリストであるとは、それが ~NIL~ であるか他のコンスセルへの参照であるということ。
コンスセルの ~CAR~ はそのリストの最初の要素であり、 ~CDR~ は残りの要素を含む他のリスト（すなわち他のコンスセル、または ~NIL~ ）である。
Common Lispはこの約束事をわかっているので、このような「コンスセル鎖」をリストとして印字する。

#+begin_src lisp :results output
  (dbg (cons 1 nil))
  (dbg (cons 1 (cons 2 nil)))
  (dbg (cons 1 (cons 2 (cons 3 nil))))
#+end_src

#+RESULTS:
: (CONS 1 NIL) => (1)
: (CONS 1 (CONS 2 NIL)) => (1 2)
: (CONS 1 (CONS 2 (CONS 3 NIL))) => (1 2 3)


~LIST~ 関数は、これらの「コンスセル合成操作」を肩代わりしてくれる。
#+begin_src lisp :results output
  (dbg (list 1))
  (dbg (list 1 2))
  (dbg (list 1 2 3))
#+end_src

#+RESULTS:
: (LIST 1) => (1)
: (LIST 1 2) => (1 2)
: (LIST 1 2 3) => (1 2 3)

コンスセルではなくリストとして見ている時には、CARやCDRの代わりに ~FIRST~ と ~REST~ という同義語の方が合っている。
#+begin_src lisp :results output
  (defparameter *list* (list 1 2 3 4))
  (dbg (first *list*))
  (dbg (rest *list*))
  (dbg (first (rest *list*)))
#+end_src

#+RESULTS:
: (FIRST *LIST*) => 1
: (REST *LIST*) => (2 3 4)
: (FIRST (REST *LIST*)) => 2

コンスセルはどんな種類の値も保持できる。また、単一のリストに型の異なるオブジェクトを保持することもできる。
#+begin_src lisp
  (list "foo" (list 1 2) 10)
#+end_src

#+RESULTS:
| foo | (1 2) | 10 |

** リサイクルな関数と構造共有の組み合わせ
リスト操作関数には、引数のリスト構造の一部を、返り値と共有するような関数(構造共有)が存在する。
一方で、効率化のために 引数のリストを返り値にリサイクルするような関数もあり、これは構造共有と相性が悪い。

実践では、リサイクルな関数を使うときはお決まりのイディオムに従うことが多い。
よく利用するイディオムは、ローカル変数に保持されたリストに対して要素を ~PUSH~ していき、関数から返すときに ~NREVERSE~ するというもの。
#+begin_src lisp :results output
  (defun upto (max)
    (let ((result nil))
      (dotimes (i max)
        (push i result)) ;PUSH
      (nreverse result))) ;NREVERSE

  (dbg (upto 10))
#+end_src

#+RESULTS:
: (UPTO 10) => (0 1 2 3 4 5 6 7 8 9)

その次によく使われるイディオムは、リサイクルな関数の戻り値を、リサイクルされた値が含まれうる場所に即座に代入し直すというもの。
例えば、 ~REMOVE~ のリサイクルバージョンである ~DELETE~ を使ったものがある
#+begin_src lisp :results output
  (defparameter *foo* (list 1 nil 2 nil 3))
  (dbg *foo*)
  (terpri)
  (setf *foo* (delete nil *foo*))
  (dbg *foo*)
#+end_src

#+RESULTS:
: *FOO* => (1 NIL 2 NIL 3)
: 
: *FOO* => (1 2 3)

#+begin_quote
 リストを操作するときは一般に関数的なスタイルでコードを記述するのがベストだ。
 自分が書く関数は引数のリストの内容にだけ依存し、引数を変更しないようにしよう。
#+end_quote

** リスト操作関数
- ~SECOND~ から ~TENTH~ まで、序数の名前がついた関数が用意されている
- 汎用の ~NTH~ はインデックスとリストの2つの引数をとり、そのリストのゼロから数えてn番目の要素を返す。
- ~CAR~ と ~CDR~ の合成関数が28種類ある。caar, cadr, cadadr... ただこれらの関数はあまり頻繁に利用されない。


** マッピング
シーケンス用の ~MAP~ のほかに、リスト専用のマッピング関数が6つある。

~MAPCAR~ は戻り値が必ずリストになる ~MAP~ 。
#+begin_src lisp :results output
  (dbg (mapcar #'(lambda (x) (* 2 x)) (list 1 2 3)))
  (dbg (mapcar #'+ (list 1 2 3) (list 10 20 30)))
#+end_src

#+RESULTS:
: (MAPCAR #'(LAMBDA (X) (* 2 X)) (LIST 1 2 3)) => (2 4 6)
: (MAPCAR #'+ (LIST 1 2 3) (LIST 10 20 30)) => (11 22 33)

そのほか、
- ~MAPLIST~ はで関数に渡されるのがリストの要素ではなくコンスセルになる。
- ~MAPCAN~ と ~MAPCON~ は、それぞれ ~MAPCAR~ と ~MAPLIST~ に似た動作をするが、新しいリストを組み立てるのではなく関数の戻り値を ~NCONC~ で繋ぎ合わせる。
  - 具体的にいうと、mapcar は関数が返したリストをネストして追加するのに対し、mapcan はリストをネストせずにつなげ合わせる。
     #+begin_src lisp :results output
       (dbg (mapcar (lambda (x) (list (+ x 10) 'x)) '(1 2 3 4)))
       (dbg (mapcan (lambda (x) (list (+ x 10) 'x)) '(1 2 3 4))) 
     #+end_src

     #+RESULTS:
     : (MAPCAR (LAMBDA (X) (LIST (+ X 10) 'X)) '(1 2 3 4)) => ((11 X) (12 X) (13 X)
     :                                                         (14 X))
     : (MAPCAN (LAMBDA (X) (LIST (+ X 10) 'X)) '(1 2 3 4)) => (11 X 12 X 13 X 14 X)

- ~MAPC~ と ~MAPL~ は実際には制御構文で、いずれも最初のリスト引数をそのまま返す。つまりマップされる関数が副作用を伴う場合に使う。for-eachだね。

参考: https://devnull.hatenablog.jp/entry/2018/04/10/144746


* 第13章 リストを超えて: コンスセルの別用途
