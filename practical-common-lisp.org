**実践Common  lisp**
#+begin_src lisp
  (defmacro dbg (expr)
  `(let ((result ,expr))
     (format t "~&~S => ~S~%" ',expr result)
     result))
#+end_src

#+RESULTS:
: DBG

#+begin_src lisp :results output
  (defun hello-world ()
  (format t "Hello, world"))
  (dbg (hello-world))
#+end_src

#+RESULTS:
: Hello, world
: (HELLO-WORLD) => NIL

* 第3章 実践:簡単なデータベース
** CDの曲を管理する簡単なデータベースを作成する。
**** リスト
#+begin_src lisp
(list 1 2 3)
#+end_src

#+RESULTS:
| 1 | 2 | 3 |

**** 属性リスト
#+begin_src lisp
  (getf (list :a 1 :b 2) :b)
#+end_src

#+RESULTS:
: 2

*** CDを表す属性リストを返す関数
#+begin_src lisp
  (defun make-cd (title artist rating ripped) (list :title title :artist artist :rating rating :ripped ripped))
#+end_src

#+RESULTS:
: MAKE-CD

*** データベースを格納するダイナミック変数と、それを操作する関数

グローバル変数には耳当てをつける
#+begin_src lisp
(defvar *db* nil)
#+end_src

#+RESULTS:
: *DB*

Create
#+begin_src lisp
  (defun add-record (cd) (push cd *db*))
  
  (add-record (make-cd "Beyond The Binary" "星宮とと, SOZEN OTSUBO" 7 t))
  (add-record (make-cd "Sakanaction" "サカナクション" 10 t))
  (add-record (make-cd "懐かしい月は新しい月" "サカナクション" 10 t))
  (add-record (make-cd "条理加速の片隅、彼女と想像の中身に関する行方 EP" "gaburyu" 8 t))
  (add-record (make-cd "NewJeans 2nd EP 'Get Up'" "NewJeans" 7 t))
  (add-record (make-cd "Perfume The Best 'P Cubed'" "Perfume" 9 t))
#+end_src

#+RESULTS:
| :TITLE | Perfume The Best 'P Cubed'                 | :ARTIST | Perfume               | :RATING |  9 | :RIPPED | T |
| :TITLE | NewJeans 2nd EP 'Get Up'                   | :ARTIST | NewJeans              | :RATING |  7 | :RIPPED | T |
| :TITLE | 条理加速の片隅、彼女と想像の中身に関する行方 EP | :ARTIST | gaburyu               | :RATING |  8 | :RIPPED | T |
| :TITLE | 懐かしい月は新しい月                         | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction                                | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Beyond The Binary                          | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING |  7 | :RIPPED | T |
| :TITLE | 懐かしい月は新しい月                         | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction                                | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Beyond The Binary                          | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING |  7 | :RIPPED | T |

Read
#+begin_src lisp
  (defun dump-db ()
    (dolist (cd *db*)
      (format t "~{~a:~10t~a~%~}~%" cd)))
#+end_src

#+RESULTS:
: DUMP-DB

*** ユーザインタラクションを改善する
~force-output~ で、改行コードを待つことなくプロンプトが印字されるように保証する。
prompt-readの戻り値は最後のフォームの値、つまりREAD-LINEを呼び出した
戻り値であり、READ-LINEは読み込んだ文字列を値として返す。
#+begin_src lisp
  (defun prompt-read (prompt)
    (format *query-io* "~a: " prompt)
    (force-output *query-io*)
    (read-line *query-io*))
#+end_src

#+RESULTS:
: PROMPT-READ

値を順々に入力してもらいながら、新たなCDのレコードを生成する。

~PARSE-INTEGER~ 関数
- 文字列から数値が読み取れなかったり、数値でないゴミが混じっていると、エラーを通知するようになっている。
    ~:junk-allowed~ に ~t~ をセットすると、エラーを抑制できる。
- 数字を1つも見つけられなかったり、文字列全部がゴミだったら、
   ~nil~ を返すようになっている。 ~OR~ マクロを使って、nilなら0を返すようにする

~Y-OR-N-P~ 関数は、y, Y, n, Nで始まらない入力があるとユーザに再度入力を促す。
#+begin_src lisp
  (defun prompt-for-cd ()
    (make-cd
     (prompt-read "Title")
     (prompt-read "Artist")
     (or (parse-integer (prompt-read "Rating") :junk-allowed t) 0)
     (y-or-n-p "Ripped [y/n]")
     ))
#+end_src

#+RESULTS:
: PROMPT-FOR-CD

仕上げに、 ~prompt-for-cd~ をユーザの気の済むまでループする関数でラップ
すれば、インタフェースの完成
#+begin_src lisp
  (defun add-cds ()
        (loop (add-record (prompt-for-cd))
              (if (not (y-or-n-p "Another? [y/n]: ")) (return))))
#+end_src

#+RESULTS:
: ADD-CDS

*** データベースの保存と読み出し

~WITH-OPEN-FILE~ マクロ
1. ファイルをオープンする
2. それを対応するストリーム変数に束縛する
3. 実行し終わったらファイルをクローズする
~WITH_STANDARD_IO_SYNTAX~ マクロ
- ~PRINT~ の動作に影響を与える可能性のある変数が、標準的な値に設定された
  状態になることを保証する

#+begin_src lisp
           (defun save-db (filename)
             (with-open-file (out filename
                                  :direction :output
                                  :if-exists :supersede)
               (with-standard-io-syntax
                 (print *db* out))))
#+end_src

#+RESULTS:
: SAVE-DB

#+begin_src lisp
(save-db "/Users/gomadoufu/ghq/github.com/gomadoufu/book-practical-common-lisp/my-cds.db")
#+end_src

#+RESULTS:
| :TITLE | Perfume The Best 'P Cubed'                 | :ARTIST | Perfume               | :RATING |  9 | :RIPPED | T |
| :TITLE | NewJeans 2nd EP 'Get Up'                   | :ARTIST | NewJeans              | :RATING |  7 | :RIPPED | T |
| :TITLE | 条理加速の片隅、彼女と想像の中身に関する行方 EP | :ARTIST | gaburyu               | :RATING |  8 | :RIPPED | T |
| :TITLE | 懐かしい月は新しい月                         | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction                                | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Beyond The Binary                          | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING |  7 | :RIPPED | T |
| :TITLE | 懐かしい月は新しい月                         | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction                                | :ARTIST | サカナクション         | :RATING | 10 | :RIPPED | T |
| :TITLE | Beyond The Binary                          | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING |  7 | :RIPPED | T |

#+begin_src lisp
  (defun load-db (filename)
      (with-open-file (in filename)
        (with-standard-io-syntax
          (setf *db* (read in)))))
#+end_src

#+RESULTS:
: LOAD-DB

#+name: ファイルからロードする
#+begin_src lisp
(load-db "/Users/gomadoufu/ghq/github.com/gomadoufu/book-practical-common-lisp/my-cds.db")
#+end_src

#+RESULTS: ファイルからロードする
| :TITLE | Perfume The Best 'P Cubed'                | :ARTIST | Perfume               | :RATING |  9 | :RIPPED | T |
| :TITLE | NewJeans 2nd EP 'Get Up'                  | :ARTIST | NewJeans              | :RATING |  7 | :RIPPED | T |
| :TITLE | 条理加速の片隅、彼女と想像の中身に関する行方 EP | :ARTIST | gaburyu               | :RATING |  8 | :RIPPED | T |
| :TITLE | 懐かしい月は新しい月                         | :ARTIST | サカナクション          | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction                               | :ARTIST | サカナクション          | :RATING | 10 | :RIPPED | T |
| :TITLE | Beyond The Binary                         | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING |  7 | :RIPPED | T |

*** データベースにクエリを投げる
~REMOVE-IF-NOT~ 関数は述語とリストを引数にとって、述語を成立させる要素だけを含む新しいリストを返す。
~#'~ は、その後に来る識別子が変数ではなく関数であることを意味する。
#+begin_src lisp 
  (remove-if-not #'(lambda (cd) (equal (getf cd :artist) "サカナクション")) *db*)
#+end_src

#+RESULTS:
| :TITLE | 懐かしい月は新しい月 | :ARTIST | サカナクション | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction       | :ARTIST | サカナクション | :RATING | 10 | :RIPPED | T |

いろんなセレクタを引数に取る関数 select
#+begin_src lisp
  (defun select (selector-fn)
    (remove-if-not selector-fn *db*))
#+end_src

#+RESULTS:
: SELECT

アーティストセレクタ
#+begin_src lisp
  (defun artist-selector (artist)
    #'(lambda (cd) (equal (getf cd :artist) artist)))
#+end_src

#+RESULTS:
: ARTIST-SELECTOR

select関数の呼び出し
#+begin_src lisp
  (select (artist-selector "サカナクション"))
#+end_src

#+RESULTS:
| :TITLE | 懐かしい月は新しい月 | :ARTIST | サカナクション | :RATING | 10 | :RIPPED | T |
| :TITLE | Sakanaction       | :ARTIST | サカナクション | :RATING | 10 | :RIPPED | T |

汎用セレクタ関数生成機 where。
関数の引数リストの先頭に ~&key~ とつけることで、以降の引数を **キーワードパラメータ** にすることができる。
キーワードパラメータを使うと、引数を好きな順序で呼び出せるようになる。
また、引数に値を与えなくても関数が動作するようになる。値を与えなかった場合、そこは ~NIL~ になる。
さらに引数にはデフォルト引数を指定できるほか、値として与えた ~NIL~ と値が与えられなかった ~NIL~ を区別するための
パラメータ ~supplied-p~ を付与することもできるようになる。
#+begin_src lisp
  (defun where (&key title artist rating (ripped nil ripped-p))
    #'(lambda (cd)
        (and
         (if title (equal (getf cd :title) title) t)
         (if artist (equal (getf cd :artist) artist) t)
         (if rating (equal (getf cd :rating) rating) t)
         (if ripped-p (equal (getf cd :ripped) ripped) t))))
#+end_src

#+RESULTS:
: WHERE

*** 既存のレコードを更新する
レコードを更新する update 関数
#+begin_src lisp
  (defun update (selector-fn &key title artist rating (ripped nil ripped-p))
     (setf *db*
         (mapcar
          #'(lambda (row)
              (when (funcall selector-fn row)
                 (if title (setf (getf row :title) title))
                 (if artist (setf (getf row :artist) artist))
                 (if rating (setf (getf row :rating) rating))
                 (if ripped-p (setf (getf row :ripped) ripped)))
              row)
          *db*)))
#+end_src

#+RESULTS:
: UPDATE

#+begin_src lisp
  (update (where :artist "サカナクション") :rating 11)
#+end_src

#+RESULTS:
| :TITLE | Perfume The Best 'P Cubed'                | :ARTIST | Perfume               | :RATING |  9 | :RIPPED | T |
| :TITLE | NewJeans 2nd EP 'Get Up'                  | :ARTIST | NewJeans              | :RATING |  7 | :RIPPED | T |
| :TITLE | 条理加速の片隅、彼女と想像の中身に関する行方 EP | :ARTIST | gaburyu               | :RATING |  8 | :RIPPED | T |
| :TITLE | 懐かしい月は新しい月                         | :ARTIST | サカナクション          | :RATING | 11 | :RIPPED | T |
| :TITLE | Sakanaction                               | :ARTIST | サカナクション          | :RATING | 11 | :RIPPED | T |
| :TITLE | Beyond The Binary                         | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING |  7 | :RIPPED | T |

既存のレコードを削除する
#+begin_src lisp
    (defun delete-rows (selector-fn)
      (setf *db* (remove-if selector-fn *db*)))
#+end_src

#+RESULTS:
: DELETE-ROWS

*** ムダを排除して勝利を収める
マクロの話が出てきた！
- 「CやC++におけるテキストベースのマクロとCommon Lispのマクロとは、名前以外に本質的に何も共有しているものはない」
  - Rustのマクロとは似ているところがあるのかも
- 「Lispのマクロの本質は、自動的なコードジェネレータだ」
#+name: 初めてのマクロ
#+begin_src lisp :results output
  (defmacro backwards (expr) (reverse expr))
  (backwards ("hello, world" t format))
#+end_src

  #+RESULTS: 初めてのマクロ
  : hello, world

シングルクォートをつけると、Lispにそのフォームを評価することをやめさせることができる。
またバッククォートをつけると、クォートと同じように全体が評価されなくなるが、コンマが前に置かれた部分式だけは評価されるようになる。
#+begin_src lisp :results scalar
    (defun make-comparison-expr (field value)
      (list 'equal (list 'getf 'cd field value)))

    (defun make-comparison-expr (field value)
      `(equal (getf cd ,field) ,value))

    (make-comparison-expr :rating 10)
#+end_src

#+RESULTS:
: (EQUAL (GETF CD :RATING) 10)

~LOOPマクロ~ を使ってみよう
#+begin_src lisp
      (defun make-comparisons-list (fields)
        (loop while fields
              collecting (make-comparison-expr (pop fields) (pop fields))))
#+end_src

#+RESULTS:
: MAKE-COMPARISONS-LIST

whereをマクロで置き換える
- ~,@~ は、続く式を評価して、それを取り囲んでいるリストと繋ぎ合わせる。
- ~&rest~ があると関数やマクロは任意個数の引数を取れるようになり、それらのリストが単一の実引数になる。
#+begin_src lisp
    (defmacro where (&rest clauses)
      `#'(lambda (cd) (and ,@(make-comparisons-list clauses))))
#+end_src

#+RESULTS:
: WHERE

~MACROEXPAND-1~ を使うと、マクロを展開してチェックできる。
#+begin_src lisp :results scalar
  (macroexpand-1 '(where :title "Beyond The Binary" :ripped t))
#+end_src

#+RESULTS:
: #'(LAMBDA (CD)
:     (AND (EQUAL (GETF CD :TITLE) "Beyond The Binary")
:          (EQUAL (GETF CD :RIPPED) T)))
: T

whereマクロを実際に使ってみよう！
#+begin_src lisp
  (select (where :title "Beyond The Binary" :ripped t))
#+end_src

#+RESULTS:
| :TITLE | Beyond The Binary | :ARTIST | 星宮とと, SOZEN OTSUBO | :RATING | 7 | :RIPPED | T |

* 第4章 シンタックスとセマンティクス
** S式
以下のどちらかのこと。
- リスト
  - カッコで括られている
  - 空白で区切って、いくつでもS式を含められる
- アトム
  - リスト以外の、コメントをのぞいた全て。
** アトムの種類
- 数値
  - 整数、分数、浮動小数点数、複素数がある
- 文字列
  - ダブルクォートでくくる
  - バックスラッシュは次の文字をエスケープし、それが何であろうと文字列中に含まれるようにする。
    - ダブルクォートとバックスラッシュの2つだけは、文字列の中で必ずエスケープしなければならない。
- シンボル
  - ~FORMAT~ や ~hello-world~ や ~*db*~ といった、「名前」。
  - カッコやクォート類、カンマやコロン、バックスラッシュはエスケープすれば、シンボルの一部として使える
  - リストの読み取り機は、エスケープされていないシンボルを、全て大文字に変換する。
  - シンボルの命名規約
    - ハイフンがよく使われる
    - ダイナミック変数の先頭と末尾に ~*~ をつける
    - 定数の先頭と末尾に ~+~ をつける
    - 下位層の関数の先頭に ~%~ をつけるLisperもいるらしい
** LispフォームとしてのS式
アトムは2種類に分類できる
- シンボル
  - 変数の名前とみなされ、その変数の現在の値として評価される。
- それ以外
  - 自己評価型 (*self-evaluating*)のオブジェクト。
  - 数値や文字列など、評価器に渡すとそれ自身が帰ってくるもののこと。

シンボルも、変数の名前に代入すれば自己評価型になる。
~T~ や ~NIL~ はこの形式で定義されている。
キーワード引数で使われる **キーワードシンボル** ~:symbol~ も、同じく自己評価型になるシンボルで、
その名前の定数が自動的に定義される。

正規のリストフォームは、すべてシンボルで始まり、
評価のされかたによって3種類に分けられる。
- 関数呼び出しフォーム
- マクロフォーム
- 特殊フォーム
** 特殊オペレータ
すべての操作を関数として定義できるわけではない。例えば関数では、 ~IF~ を定義できない。
なぜなら、通常の関数ならば評価は左・内側から始まってしまうから。
以下の ~IF~ がもし関数なら、 ~x~ が何であれ、常に yes no が表示され、それから ~IF~ の評価が始まってしまい、
期待する動作にならない。
#+begin_src lisp
  (if x (format t "yes") (format t "no"))
#+end_src
この問題を解決するため、Common Lispには関数ではできないことをするための **特殊オペレータ** が25個ある。
リストの先頭が特殊オペレータの名前だった場合、式の残りはその特殊オペレータのルールに従って評価される。
** マクロ
ユーザに対して、Lispのシンタックスを拡張する手段を提供するのがマクロ。
マクロは「S式を引数に取って、そのマクロフォームの代わりに評価されるLispフォームを返す関数」と考えることができる。
- マクロはコンパイル時に展開される。
- 評価器は、マクロがマクロ関数に渡る前にマクロフォームの要素を評価することはない。
  よって、マクロフォームはきちんとしたLispフォームでなくても良い。
- ループ構文はいつだってマクロだ。
** 真、偽、そして等しさ
*** 真偽値
Common Lispにおいては、 ~NIL~ だけが唯一の偽の値で、他のあらゆるものが真。
標準の真の値はシンボル ~T~ で、具体的な値を持たない ~非NIL~ として使われる。

~NIL~ はアトムでもありリストでもあり(Common Lispでこの特徴を持つのはNILだけ)、空リストを表すのにも使われる。
また、読取器は空リストを見ると ~NIL~ として読む。
~nil~ = ~()~ = ~'nil~ = '()
*** 同一性の判定
Common Lispには、等価性を判定する述語が型ごとに用意されている。
例えば数値の比較には ~=~ を使い、文字の比較には ~CHAR=~ を使う。

Lispオブジェクト全般に使える、等価性判定の総称的な述語が4つある
- EQ
  - シンボル用。
  - 「オブジェクト同一性」(object identity)を比較する。
  - ただし数や文字のオブジェクト同一性は、処理系でそれらの型がどのように実装されているかに依存する
  - 数値や文字になり得る値の比較には、 ~EQ~ を使うべきではない。
- EQL
  - シンボル・数値・文字用。
  - ~EQL~ は ~EQ~ と同じようにオブジェクト同一性を判定する述語だが、同じ数値や文字の値を表している同じクラスの
    同じオブジェクトは、常に等しいと判定されると保証されている
  - 色々なスタイルがあるが、この本では *比較には常に ~EQL~ を使う* 。
- EQUAL
  - なんでも用。直感的。
  - ~EQL~ より等価性の判定基準が甘く、異なるオブジェクトでも等しいとみなされる
  - 文字列や配列、パス名について、ぱっと見で等しそうなら真になる。
  - その他のデータ型については ~EQL~ を使って判定される。
- EQUALP
  - なんでも用。かなりざっくり判定。
  - ~EQUAL~ よりさらに判定基準が甘い。
  - 文字列は、大文字小文字の違いがあっても等しいとみなされる
  - 数値は、数学的に同じなら等しいとみなされる。 ~(equalp 1 1.0)~ は真。
  - ~EQUALP~ からなるリスト同士は ~EQUALP~ であり、 ~EQUAL~ からなる配列も ~EQUALP~ である
  - その他のデータ型については ~EQL~ を使って判定される。
** Lispコードの書式
インデントは、コードの構造を反映したものにする。
括弧を書き間違えると、自動フォーマットしたときにインデントがおかしくなるので、気づけるはず(とのこと)。
- 意味的に同じだが改行が必要な場合は、同じレベルのインデントにする
- 関数・マクロ・特殊フォームは、本体をスペース2つ分インデントする
- *閉じ括弧は、閉じようとするリストの最後の要素と同じ行に書くこと。*
- コメント 1~4つのセミコロンを使う
  - セミコロン4つはファイルヘッダ
  - セミコロン3つは意味段落で使う
  - セミコロン1つは、文末の1行コメント
* 第5章 関数
** 新しい関数の定義
関数は ~defun~ マクロを使って定義される。
#+begin_src lisp :eval no
      (defun name (parameter*)
        "省略可能なドキュメンテーション文字列"
        body-form*)
#+end_src

*name* には、どんなシンボルでも使える。
- 変換系の関数には、よく ~string->widget~ のような名前がつけられる
- スネークケースやキャメルケース・パスカルケースではなく、ハイフンを使ったケバブケースで命名する。
  
*parameter* のリストは、関数を呼ぶときに渡す引数を保持するのに使う変数を定義する。以下のように色々種類がある
- 必須パラメータ
- オプショナルパラメータ
- マルチプルパラメータ
- キーワードパラメータ

パラメータリストの後に続く文字列リテラルは、関数の目的を説明する *ドキュメント* になる。
この文字列は関数の名前と自動的に対応づけられ、後で ~DOCUMENTATION~ 関数で取り出すことができる。

*body-form* は任意の個数のLisp式で構成される。
これらは関数が呼び出されるときに順番に評価され、最後の式の値が関数の値として返される。
最後の値を戻り値にしたくないときには、 ~RETURN-FROM~ という特殊オペレータを使ってreturnすることもできる。
** 関数のパラメータリスト
*** 必須パラメータ
パラメータリストが単純に、変数の名前からなるリストの時、そのパラメータを *必須パラメータ* と呼ぶ。
関数が呼び出される時、必須パラメータには、対応する実引数が必要になる。
必須パラメータと実引数の数が合わないと、Lispはエラーを通知する。
*** オプショナルパラメータ
関数呼び出しをするときに、一部の引数は適当なデフォルト値にして、関数側ででうまくやってほしい場面がある。
オプショナルパラメータを使うと、細かい値を気にしない呼び出し元に対しては適当なデフォルト値にして、
そうでない呼び出し元からは特定の値を受け取れるようにできる。

オプショナルパラメータ付きの関数を定義するには、すべての必須パラメータの *後に、*
~&optional~ というシンボルを置き、その後にオプショナルパラメータの名前を続ける。
#+begin_src lisp
  (defun foo (a b &optional c d) (list a b c d))
#+end_src

#+RESULTS:
: FOO

この関数が呼ばれたとき、引数は最初に必須パラメータに束縛され、さらに引数が残っていたら、
その値はオプショナルパラメータに束縛される。引数が残っていなければ、オプショナルパラメータは ~NIL~ になる。

#+begin_src lisp :results output
  (dbg (foo 1 2))
#+end_src

#+RESULTS:
: [DEBUG] (FOO 1 2) => (1 2 NIL NIL)

#+begin_src lisp :results output
  (dbg (foo 1 2 3))
#+end_src

#+RESULTS:
: [DEBUG] (FOO 1 2 3) => (1 2 3 NIL)

#+begin_src lisp :results output
  (dbg (foo 1 2 3 4))
#+end_src

#+RESULTS:
: [DEBUG] (FOO 1 2 3 4) => (1 2 3 4)


~NIL~ 以外のデフォルト値を指定するには、パラメータの名前の代わりに、名前とデフォルト値からなるリストを指定する。
#+begin_src lisp
  (defun foo (a &optional (b 10)) (list a b))
#+end_src

#+RESULTS:
: FOO

#+begin_src lisp :results output
  (dbg (foo "hello"))
#+end_src

#+RESULTS:
: [DEBUG] (FOO "hello") => ("hello" 10)

#+begin_src lisp :results output
  (dbg (foo "hello" "world"))
#+end_src

#+RESULTS:
: [DEBUG] (FOO "hello" "world") => ("hello" "world")

デフォルト値を設定する式では、すでにパラメータリストに登場している値を参照できる。
例えば矩形を描画する関数を書いているとして、特に正方形を手軽に描画したいとすると、こんなふうに書ける。
#+begin_src lisp :eval no
  (defun make-rectangle (width &optional (height width)) ...)
#+end_src


パラメータを指定するリストのデフォルト値の式の後に追加の変数を設定すると、オプショナル引数の実引数が
デフォルト値なのかカスタムの値なのかを判定できる。
#+begin_src lisp
  (defun foo (a b &optional (c 3 c-supplied-p))
    (list a b c c-supplied-p))
#+end_src

#+RESULTS:
: FOO

この関数では、 ~c~ がカスタムの値なら ~c-supplied-p~ が真に、そうでなければ ~NIL~ に束縛される。
このように使う変数の名前は、実際のパラメータの名前に ~-supplied-p~ をつけたものにするのが慣例。
#+begin_src lisp :results output
  (dbg (foo 1 2))
#+end_src

#+RESULTS:
: [DEBUG] (FOO 1 2) => (1 2 3 NIL)

#+begin_src lisp :results output
  (dbg (foo 1 2 100))
#+end_src

#+RESULTS:
: [DEBUG] (FOO 1 2 100) => (1 2 100 T)

*** レストパラメータ
必須パラメータとオプショナルパラメータに割り当てた後の残りの引数を、
シンボル ~&rest~ の後ろのパラメータにまとめることができる。
これはレストパラメータと呼ばれ、この残りの引数はリストとしてまとめられる。
レストパラメータを使うと、可変長引数を実現できる。
#+begin_src lisp
  (defun my+ (&rest numbers)
  (if (null numbers)
      0
      (+ (car numbers) (apply #'my+ (cdr numbers)))))
  (dbg (my+ 1 2 3))
#+end_src

#+RESULTS:
: MY+

*** キーワードパラメータ
キーワードパラメータを使うと、オプショナルパラメータよりももっと柔軟に、指定した位置の引数にだけ値を渡すことができる。
関数にキーワードパラメータを設定するには、必須パラメータと ~&optional~ および ~&rest~ の各パラメータの後に、
 ~&key~ というシンボルと任意の数の識別子を、リストとしてまとめておく。
#+begin_src lisp :eval no
  (defun foo (&key a b c) (list a b c))
#+end_src

各キーワードパラメータは同じ名前のキーワードの直後の値に束縛される。もし与えられたキーワードに対応する実引数が
与えられなかったら、対応するパラメータにはデフォルト値が割り当てられる。
デフォルト値の指定方法まわりは、オプショナルパラメータと同様。 ~-supplied-p~ も使える。
#+begin_src lisp
  (defun foo (&key (a 0) (b 0 b-supplied-p) (c (+ a b)))
    (list a b c b-supplied-p))
#+end_src

#+RESULTS:
: FOO

#+begin_src lisp :results output
  (dbg (foo :a 1 :c 3))
#+end_src

#+RESULTS:
: [DEBUG] (FOO :A 1 :C 3) => (1 0 3 NIL)

#+begin_src lisp :results output
  (dbg (foo :a 1 :c 3 :b 2))
#+end_src

#+RESULTS:
: [DEBUG] (FOO :A 1 :C 3 :B 2) => (1 2 3 T)

** 関数の戻り値
デフォルトでは、関数の最後の式を評価した値が、その関数の戻り値になる。
アーリーリターンしたい時は、特殊オペレータ ~RETURN-FROM~ が使える。
~RETURN-FROM~ はブロックから抜けるためのもので、関数と直接関係があるわけではない。
#+begin_src lisp :eval no
  (defun foo (n)
    (dotimes (i 10)
      (dotimes (j 10)
        (when (> (* i j) n)
          (return-from foo (list i j)))))
#+end_src

** データとしての関数または高階関数
*** 関数オブジェクトの取得
Lispでは、関数はオブジェクトの一種でしかない。関数を ~DEFUN~ で定義する時には、実際には2つのことをやっている。
- 新しい関数オブジェクトの生成
- そのオブジェクトに名前をつけること

関数オブジェクトを得る仕組みは ~FUNCTION~ という特殊オペレータが提供する。
~FUNCTION~ は引数を1つ取り、引数の名前を持つ関数オブジェクトを返す。
#+begin_src lisp :results output
  (defun foo (x) (* 2 x))
  (dbg (function foo))
#+end_src

#+RESULTS:
: [DEBUG] #'FOO => #<FUNCTION FOO>

また、 ~#'~ と書くことで、 ~FUNCTION~ と同じ効果を得られる。
#+begin_src lisp
  #'foo
#+end_src

#+RESULTS:
: #<FUNCTION FOO>

*** 関数オブジェクトの起動
関数オブジェクトを手に入れたら、それを起動する必要がある。起動の仕方は2種類ある
- ~FUNCALL~
- ~APPLY~
両者は、呼び出す関数への引数の渡し方に違いがある。

**** FUNCALL
~FUNCALL~ は、渡す引数の個数が静的に判明しているときに使う。
#+begin_src lisp :results output
  (dbg (foo 2))
  (dbg (funcall #'foo 2))
#+end_src

#+RESULTS:
: [DEBUG] (FOO 2) => 4
: [DEBUG] (FUNCALL #'FOO 2) => 4

#+begin_src lisp :results output
  (defun plot (fn min max step)
    (loop for i from min to max by step do
      (loop repeat (funcall fn i) do (format t "*"))
      (format t "~%")))
  (plot #'exp 0 4 1/2)
#+end_src

#+RESULTS:
: *
: **
: ***
: *****
: ********
: *************
: *********************
: **********************************
: *******************************************************

**** APPLY
~FUNCALL~ は、引数リストが実行時にしかわからない場合には使いづらい。
そのような場合には、引数リストをそのまま渡せる ~APPLY~ を使う。
#+begin_src lisp :eval no
  (apply #'plot plot-data)
#+end_src

~APPLY~ は、適用される関数のとる引数が ~&optional~ なのか ~&rest~ なのか ~&key~ なのかは気にしない。
引数の数だけ気にする。

** 無名関数
いちいち新しい関数を定義するのが面倒な場合は、 ~LAMBDA~ 式を使って無名の関数を作れる。
#+begin_src lisp :eval no
  (lambda (parameters) body)
#+end_src
~LAMBDA~ は特別な構文なので、このフォームは仕様上、値として評価されることはない。
しかし歴史的な経緯から、特別な記号を何もつけずとも、全体がそのまま値として評価されてしまう。
よって ~LAMBDA~ を関数オブジェクトとして扱う場合に ~#'~ をつける派閥とつけない派閥がいる。本書では、常に ~#'~ をつけるとのこと。
#+begin_src lisp :results output
  (dbg (funcall #'(lambda (x y) (+ x y)) 2 3))
#+end_src

#+RESULTS:
: [DEBUG] (FUNCALL #'(LAMBDA (X Y) (+ X Y)) 2 3) => 5

関数を引数として別の関数に渡す必要があって、その渡す必要のある関数がインラインで書けるくらいシンプルな場合に、無名関数が活躍する。
#+begin_src lisp :results output
  (defun plot (fn min max step)
    (loop for i from min to max by step do
      (loop repeat (funcall fn i) do (format t "*"))
      (format t "~%")))
  
  (plot #'(lambda (x) (* 2 x)) 0 10 1)
#+end_src

~LAMBDA~ 式の重要な用途にクロージャの作成がある。
クロージャとは、それを作成した時点での環境の一部をキャプチャした関数のこと。

* 第6章 変数
** 変数の基礎
Common Lispの変数は *動的型付け* であり、かつ *強い型付け* である。

すべての値はオブジェクトへの参照であり、変数に新しい値を代入しても、変化するのはアドレスのみ。
ただし、もし変数が保持しているのがmutableなオブジェクトへの参照なら、その参照を使ってオブジェクトそのものを変更でき、
変更の結果は同じオブジェクトを参照しているすべてのコードから見えるようになる。

新しい変数を導入する方法の一つは、 ~DEFUN~ で関数を定義すること。
関数を定義すると、パラメータリストが引数を保持する変数の定義となる。
関数が呼ばれるたびに、Lispは実引数を保持するための新しい *束縛(binding)* を作る。束縛とは、変数の実行時における発現のこと。
ある一つの変数は、プログラムの実行中に異なる複数の束縛を持てる。


そのほかに、特殊オペレータ ~LET~ でも変数を導入できる。
#+begin_src lisp :eval no
 (let (variable*)
   body-form*)
#+end_src
~variable~ は変数の初期化フォームで、変数名とその初期値のリスト または ただの変数名(値は ~NIL~ になる) のどちらかがくる。

~LET~ フォームが評価されるときには、
1. まず初期値のフォームがすべて評価され、
2. 次に新しい束縛がつくられて初期化された後、
3. 本体のフォーム ~BODY-FORM~ が実行される。

関数のパラメータや LET の変数の *スコープ(scope)* は、変数を導入したフォームによって制限される。
関数を定義するフォームや ~LET~ フォームは、 *束縛フォーム(binding form)* と呼ばれている。
レキシカル変数とダイナミック変数とでは使っているスコープの仕組みが少し違うが、両方とも束縛フォームによってスコープが区切られている。

おなじ名前の変数を導入する束縛フォームを入れ子にすると、最も内側の変数の束縛が外側の束縛を *隠す(shadow)* 。

~LET~ の変種の ~LET*~ という束縛フォームもある。LETでは本体でしか変数の名前を使えないが、LET*では初期化フォーム内で、それより前の
初期化フォームに出てきた束縛を使うことができる。

** レキシカル変数とクロージャ
Common Lispでは、束縛フォームが導入する変数は、すべてデフォルトで *レキシカルなスコープを持つ* 。
また、レキシカルスコープと無名関数を組み合わせると、 ~クロージャ(closure：閉包)~ を実現できる。
以下の無名関数は、 ~LET~ の外から起動された場合でも、 ~count~ の値を利用することができる。
#+begin_src lisp :eval no
  (let ((count 0)) #'(lambda () (setf count (1+ count))))
#+end_src

ひとつのクロージャに複数の変数を閉じ込めることもできる
#+begin_src lisp :results output
  (defparameter *fn* (let ((count 0)) (list #'(lambda () (incf count)) #'(lambda () (decf count)) #'(lambda () count))))
  (dbg (funcall (car *fn*)))
  (dbg (funcall (car *fn*)))
  (dbg (funcall (car *fn*)))
  (dbg (funcall (cadr *fn*)))
#+end_src

#+RESULTS:
: [DEBUG] (FUNCALL (CAR *FN*)) => 1
: [DEBUG] (FUNCALL (CAR *FN*)) => 2
: [DEBUG] (FUNCALL (CAR *FN*)) => 3
: [DEBUG] (FUNCALL (CADR *FN*)) => 2

** ダイナミック変数。またの名をスペシャル変数
レキシカル変数も便利だが、グローバル変数にも理にかなった使い方がある。
Common Lispには *ダイナミック変数* が用意されている。

グローバルなスコープを持つ変数を作る方法は、 ~DEFVAR~ と ~DEFPARAMETER~ の2通りがある。
両方とも変数名と初期値、それから省略可能なドキュメンテーション文字列を取る。
#+begin_src lisp :eval no
  (defvar *count* 0 "製造済みの部品数")
  (defparameter *gap-tolerance* 0.001 "部品間の隙間の許容幅")
#+end_src
 ~DEFPARAMETER~ では評価されるたびに常に初期値を代入するが、 ~DEFVAR~ は変数が未定義だった場合のみ初期値を代入する。
 変数を定義するとき、その変数を使うソースコードを変更したとしても維持しておきたいデータには、 ~DEFVAR~ を使う。
 ソースコードに直接影響するようなパラメータなら、 ~DEFPARAMETER~ が適切。

 ダイナミック変数には、一般的なグローバル変数とは異なる性質がある。
 ダイナミック変数を ~LET~ フォームや関数のパラメータなどで束縛すると、その束縛フォームが続いている間は、
 グローバルな変数の束縛が束縛フォームの入り口で作られた束縛(ダイナミックな束縛)に置き換えられる。
 また、これはレキシカルな束縛とも違って、束縛フォームを実行している間に起動されるどんなコードからでも、
 このダイナミックな束縛を参照できる。
 #+begin_src lisp :eval no
   ; stuffはLETで作られた束縛を参照する
   ; さらに、letで束縛されている間に*standard-output*にアクセスするすべてのコードも、LETで作られた束縛を参照する
   (let ((*standard-output* *some-other-stream*))
     (stuff))
 #+end_src
 考え方としては、ダイナミック変数への束縛は変数の「束縛スタック」の一番上にプッシュされると思うとよい
 
** 定数
Common Lispでは定数はグローバルであり、 ~DEFCONSTANT~ によって定義される。
ダイナミック変数に対する ~*~ の命名規約と同じように、定数には ~+~ をつけることになっている。

** 代入
束縛をしたらできることは2つ。現在の値を得ることと、新しい値を設定すること。
現在の値を得るには、変数を参照するだけでいい。
束縛して新しい値を代入するには、 ~SETF~ マクロを使う。
#+begin_src lisp :eval no
  (setf x 10)
  (setf x 1 y 2 z 3) ;複数一気に束縛できる
  (setf x (setf y (random 10))) ;setfは代入した値を返す
#+end_src

** 一般化代入
Common Lispでは、配列やハッシュテーブル、リストといったどんなデータ構造への代入であっても、 ~SETF~ が使える。
#+begin_src lisp :eval no
  (setf x 10) ;値
  (setf (aref a 0) 10) ;配列
  (setf (gethash 'key hash) 10) ;ハッシュテーブル
  (setf (field o) 10) ;fieldという名前のスロット
#+end_src

** 束縛された値を変更する別のやり方
どんな代入も ~SETF~ で表現できるが、値を変更して再代入するような場合は、独自のオペレータにやらせるのが一般的。
たとえば、インクリメント・デクリメントをする ~INCF~, ~DECF~ など
#+begin_src lisp :eval no
  (incf x)
  (decf x)
  (incf x 10)
#+end_src
これらは *モディファイマクロ* と呼ばれる、 ~SETF~ の上に作られたマクロである。

モディファイマクロには他に ~PUSH~, ~POP~, ~PUSHNEW~, ~ROTATEF~, ~SHIFTF~ などがある。
~ROTATEF~ は、束縛と束縛とで値を入れ替える。要するにswapだ
#+begin_src lisp :results output
  (let ((a 10) (b 20))
    (princ a)
    (print b)
    (rotatef a b)
    (print a)
    (print b))
#+end_src

#+RESULTS:
: 10
: 20 
: 20 
: 10

~SHIFTF~ は、値をひとつ左にずらす。3番目の引数の値は2番目の引数に束縛され、2番目の引数の値は1番目の引数に束縛される。
フォーム全体として、1番目の引数を返す。

* 第7章 マクロ
マクロはLispに組み込まれた、言語を拡張できる機能。

** WHENとUNLESSとCOND
#+begin_src lisp :eval no
  (defmacro when (condition &rest body)
   `(if ,condition (progn ,@body)))

  (defmacro unless (condition &rest body)
   `(if (not ,condition) (progn ,@body)))
#+end_src

IFやWHENやUNLESSよりもっと複雑な条件分岐をしたいときは、 ~COND~ マクロが便利。
#+begin_src lisp :eval no
  (cond (a (do-x))
        ((b-somepredicate-p) (do-y)) ;条件部はテスト関数でも可
        (t (do-z) (do-s) (do-w))) ;条件が真だった時に実行する式は複数かける
#+end_src

** DOLISTとDOTIMES
#+begin_src lisp :results output
  (dolist (x '(1 2 3)) (print x))
#+end_src

#+RESULTS:
: 
: 1 
: 2 
: 3

中断には ~RETURN~ が使える。
#+begin_src lisp :results output
  (dolist (x '(1 2 3)) (print x) (if (evenp x) (return)))
#+end_src

#+RESULTS:
: 
: 1 
: 2 

#+begin_src lisp :results output
  (dotimes (x 20)
      (dotimes (y 20)
        (format t "~3d " (* (1+ x) (1+ y))))
  (format t "~%"))
#+end_src

#+RESULTS:
#+begin_example
  1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20 
  2   4   6   8  10  12  14  16  18  20  22  24  26  28  30  32  34  36  38  40 
  3   6   9  12  15  18  21  24  27  30  33  36  39  42  45  48  51  54  57  60 
  4   8  12  16  20  24  28  32  36  40  44  48  52  56  60  64  68  72  76  80 
  5  10  15  20  25  30  35  40  45  50  55  60  65  70  75  80  85  90  95 100 
  6  12  18  24  30  36  42  48  54  60  66  72  78  84  90  96 102 108 114 120 
  7  14  21  28  35  42  49  56  63  70  77  84  91  98 105 112 119 126 133 140 
  8  16  24  32  40  48  56  64  72  80  88  96 104 112 120 128 136 144 152 160 
  9  18  27  36  45  54  63  72  81  90  99 108 117 126 135 144 153 162 171 180 
 10  20  30  40  50  60  70  80  90 100 110 120 130 140 150 160 170 180 190 200 
 11  22  33  44  55  66  77  88  99 110 121 132 143 154 165 176 187 198 209 220 
 12  24  36  48  60  72  84  96 108 120 132 144 156 168 180 192 204 216 228 240 
 13  26  39  52  65  78  91 104 117 130 143 156 169 182 195 208 221 234 247 260 
 14  28  42  56  70  84  98 112 126 140 154 168 182 196 210 224 238 252 266 280 
 15  30  45  60  75  90 105 120 135 150 165 180 195 210 225 240 255 270 285 300 
 16  32  48  64  80  96 112 128 144 160 176 192 208 224 240 256 272 288 304 320 
 17  34  51  68  85 102 119 136 153 170 187 204 221 238 255 272 289 306 323 340 
 18  36  54  72  90 108 126 144 162 180 198 216 234 252 270 288 306 324 342 360 
 19  38  57  76  95 114 133 152 171 190 209 228 247 266 285 304 323 342 361 380 
 20  40  60  80 100 120 140 160 180 200 220 240 260 280 300 320 340 360 380 400 
#+end_example

** DO
ループの終了判定に任意の式を使いたい時は、より柔軟な ~DO~ ループが使える。
~DO~ では任意の数のループ変数を束縛でき、ループの各段階において値を変更する方法も利用者が完全に制御できる。
#+begin_src lisp :eval no
  (do ((変数1 初期値1 ステップ式1)
     (変数2 初期値2 ステップ式2)
     …)
    (終端テスト 結果式)
  ループの本体…)
#+end_src
以下のコードでは、 ~n~, ~cur~, ~next~ が変数で、 ~(= 10 n)~ がループを抜ける条件になっている。
#+begin_src lisp
  (do ((n 0 (1+ n))
       (cur 0 next)
       (next 1 (+ cur next)))
      ((= 10 n) cur))
#+end_src
混乱するけど、 ~DO~ ループには上記のように、ループの本体が全く要らない場合がある。引数だけで計算を終えている。


ループの本体を書くとこんな感じ。
#+begin_src lisp :results output
  (do ((n 0 (1+ n))
       (cur 0 next)
       (next 1 (+ cur next)))
      ((= 10 n) cur)
  (print cur))
#+end_src

#+RESULTS:
#+begin_example

0 
1 
1 
2 
3 
5 
8 
13 
21 
34 
#+end_example

引数リストを空にすることで、無限ループも書ける。
~DO~ の代わりに、 ~LOOP~ マクロを使うこともある。
        
* 第8章 マクロ：自分で定義しよう
マクロはあまりにうまく言語に統合されているので関数のように見えるが、マクロは関数とは全く異なるレベルの完全に違う抽象である。

**マクロを書くステップ**
1. マクロ呼び出しのサンプルを書き、その展開形を書く。またはその逆をやる
2. マクロ呼び出しのサンプルから展開形を生成するコードを書く。
3. マクロによる抽象化に漏れがないことを確認する。

**マクロを書く時の注意点**
- マクロを呼び出す時に出現するのと同じ順序で評価されるように、すべての部分フォームを配置すること。引数のパラメータなど。
- 部分フォームが一度だけ評価されるようにすること。展開形の中で引数のフォームを評価して、その値を変数で保持すると良い
- 展開形の中で使う変数の名前は、展開時に1度だけ ~GENSYM~ を使って作ること。

** DEFMACRO
マクロは ~DEFMACRO~ フォームで定義される
#+begin_src lisp :eval no
  (defmacro name (parameter*)
    "省略可能なドキュメンテーション文字列"
    body-form*)
#+end_src

* 第11章 コレクション
** ベクタ
シーケンスのサブタイプで、リストの兄弟。固定サイズと可変サイズがある。

*** VECTOR関数
固定サイズのベクタは ~VECTOR~ 関数で作ることができる。 ~VECTOR~ は任意個の引数をとり、
引数で与えた要素を含む固定サイズのベクタを新しく確保する。
#+begin_src lisp :results output
  (dbg (vector 1 2 3))
#+end_src

#+RESULTS:
: [DEBUG] (VECTOR 1 2 3) => #(1 2 3)

このように、ベクタのリテラル表記は ~#(...)~ となる。
ベクタのリテラルオブジェクトに変更を加えた場合の動作は定義されていないので、リテラル表記ではなく ~VECTOR~ 関数でベクタを生成するべき。

*** MAKE-ARRAY関数
~MAKE-ARRAY~ は ~VECTOR~ よりも汎用の関数で、固定サイズと可変サイズの両方のベクタを作れる。
引数として、配列の次元を表すリストを受け取る。
#+begin_src lisp
  (make-array 5 :initial-element nil)
#+end_src

#+RESULTS:
| NIL | NIL | NIL | NIL | NIL |

可変長のベクタを作るには、 ~fill-pointer~ 引数を渡す。
次の ~MAKE-ARRAY~ 呼び出しは5つのcapacityを持つが、フィルポインタが0のためlengthが空っぽであるように見える。
#+begin_src lisp :results output
  (dbg (make-array 5 :fill-pointer 0))
#+end_src

#+RESULTS:
: [DEBUG] (MAKE-ARRAY 5 :FILL-POINTER 0) => #()

可変ベクタの末尾に要素を追加するには、 ~VECTOR-PUSH~ を使う。これはフィルポインタの値をインクリメントして、追加した要素のインデックスを返す。
~VECTOR-POP~ は、最後に追加された要素を返し、フィルポインタの値をデクリメントする。

#+begin_src lisp :results output
  (defparameter *x* (make-array 5 :fill-pointer 0))

  (dbg (vector-push 'a *x*))
  (dbg (vector-push 'b *x*))
  (dbg (vector-push 'c *x*))
  (dbg *x*)
  (dbg (vector-pop *x*))
  (dbg (vector-pop *x*))
  (dbg (vector-pop *x*))
#+end_src

#+RESULTS:
: [DEBUG] (VECTOR-PUSH 'A *X*) => 0
: [DEBUG] (VECTOR-PUSH 'B *X*) => 1
: [DEBUG] (VECTOR-PUSH 'C *X*) => 2
: [DEBUG] *X* => #(A B C)
: [DEBUG] (VECTOR-POP *X*) => C
: [DEBUG] (VECTOR-POP *X*) => B
: [DEBUG] (VECTOR-POP *X*) => A


上限がない、capacityが自動で大きくなるようなベクタを作るには、 ~MAKE-ARRAY~ にキーワード引数 ~:adjustable~ を追加する。
可変ベクタに要素を追加するには、 ~VECTOR-PUSH-EXTEND~ を使う。

#+begin_src lisp :results output
  (defparameter *x* (make-array 1 :fill-pointer 0 :adjustable t))

  (dbg (vector-push-extend 'a *x*))
  (dbg (vector-push-extend 'b *x*))
  (dbg (vector-push-extend 'c *x*))
  
  (dbg *x*)
#+end_src

#+RESULTS:
: [DEBUG] (VECTOR-PUSH-EXTEND 'A *X*) => 0
: [DEBUG] (VECTOR-PUSH-EXTEND 'B *X*) => 1
: [DEBUG] (VECTOR-PUSH-EXTEND 'C *X*) => 2
: [DEBUG] *X* => #(A B C)

*** 特殊ベクタ
これまで出てきたベクタは任意の型のオブジェクトを持つことができる汎用のベクタだった。
Common Lispでは、要素の型をある特定の型に制限した ~特殊ベクタ~ を作ることもできる。

文字列は特殊ベクタの一種。 ~MAKE-ARRAY~ にキーワード引数 ~:element-type~ を与えるとベクタの要素の型指定が
できるが、ここに ~CHARACTER~ を指定すれば文字列になる。
#+begin_src lisp :results output
   (dbg (make-array 5 :fill-pointer 0 :adjustable t :element-type 'character))
#+end_src

#+RESULTS:
: [DEBUG] (MAKE-ARRAY 5 :FILL-POINTER 0 :ADJUSTABLE T :ELEMENT-TYPE 'CHARACTER) => ""
                        
*** シーケンスとしてのベクタ
シーケンス関数について。

長さを返す ~LENGTH~ と要素を取得する ~ELT~ (elementの略)
#+begin_src lisp :results output
  (defparameter *x* (vector 1 2 3))
  (defparameter *hello* "hello world")

  (dbg (length *x*))
  (dbg (length *hello*))

  (dbg (elt *x* 0))
  (dbg (elt *x* 1))
  (setf (elt *x* 0) 100)
  (dbg *x*)

  (dbg (elt *hello* 0))
  (setf (elt *hello* 0) #\H)
  (dbg *hello*)
#+end_src

#+RESULTS:
: [DEBUG] (LENGTH *X*) => 3
: [DEBUG] (LENGTH *HELLO*) => 11
: [DEBUG] (ELT *X* 0) => 1
: [DEBUG] (ELT *X* 1) => 2
: [DEBUG] *X* => #(100 2 3)
: [DEBUG] (ELT *HELLO* 0) => #\h
: [DEBUG] *HELLO* => "Hello world"

シーケンス反復関数
~COUNT~, ~FIND~, ~POSITION~, ~REMOVE~, ~SUBSTITUTE~
#+begin_src lisp :results output
  (dbg (count 1 #(1 2 1 2 3 1 2 3 4)))

  (dbg (remove 1 '(1 2 1 2 3 1 2 3 4)))
  (dbg (remove #\a "foobarbaz"))

  (dbg (substitute 10 1 #(1 2 1 2 3 1 2 3 4)))
  (dbg (substitute #\x #\b "foobarbaz"))

  (dbg (find 1 '(1 2 1 2 3 1 2 3 4)))  ; 値が見つかればその値を返す(tとして)

  (dbg (position 1 #(1 2 1 2 3 1 2 3 4)))
#+end_src

#+RESULTS:
: (COUNT 1 #(1 2 1 2 3 1 2 3 4)) => 3
: (REMOVE 1 '(1 2 1 2 3 1 2 3 4)) => (2 2 3 2 3 4)
: (REMOVE #\a "foobarbaz") => "foobrbz"
: (SUBSTITUTE 10 1 #(1 2 1 2 3 1 2 3 4)) => #(10 2 10 2 3 10 2 3 4)
: (SUBSTITUTE #\x #\b "foobarbaz") => "fooxarxaz"
: (FIND 1 '(1 2 1 2 3 1 2 3 4)) => 1
: (POSITION 1 #(1 2 1 2 3 1 2 3 4)) => 0

シーケンス反復関数には各種キーワード関数を指定することができる。
~:test~ ... パラメータで渡した値とシーケンスの要素との比較に使う2引数関数を指定する
~:key~ ... 実際のシーケンスの要素から、キーを取り出すための1引数関数
~:start~, ~:end~ ... シーケンス反復関数の適用範囲を制限する
~:from-end~ ... シーケンス関数の適用を逆順(末尾から)にする
~:count~ ... ~REMOVE~ と ~SUBSTITUTE~ の時、この操作を実行する上限数を表す。 ~NIL~ ならすべてを意味する。デフォルトで ~NIL~ 。
#+begin_src lisp :results output
  (dbg (count "foo" #("foo" "bar" "baz") :test #'string=)) ;テスト関数にstring=を指定
  (dbg (find 'a #((a 10) (b 20) (c 30) (a 100)) :key #'first)) ;シーケンスの要素のfirstに対してfind
  (dbg (find 'a #((a 10) (b 20) (c 30) (a 100)) :key #'first :from-end t)) ;さらに、逆順でfind
  (dbg (remove #\a "ababab" :count 2)) ;最大2個までremoveする
#+end_src

#+RESULTS:
: (COUNT "foo" #("foo" "bar" "baz") :TEST #'STRING=) => 1
: (FIND 'A #((A 10) (B 20) (C 30) (A 100)) :KEY #'FIRST) => (A 10)
: (FIND 'A #((A 10) (B 20) (C 30) (A 100)) :KEY #'FIRST :FROM-END T) => (A 100)
: (REMOVE #\a "ababab" :COUNT 2) => "bbab"


これらシーケンス反復関数それぞれについて、 ~<FUNCTION>-IF~ と ~<FUNCTION>-IF-NOT~ という高階関数の亜種が用意されている。
IFがついた方はテスト関数を受け取り、それが真を返す要素に対してのみ、countやfindやsubstituteを行う。
IF-NOTの方もテスト関数を受け取るが、それが偽を返す要素に対してのみ、countやfindやsubstituteを行う。
#+begin_src lisp :results output
  (dbg (count-if #'evenp #(1 2 3 4 5)))

  (dbg (position-if #'digit-char-p "abcd0001"))

  (dbg (remove-if-not #'(lambda (x) (char= (elt x 0) #\f)) #("foo" "bar" "baz" "foom")))
  ;; ("foo" "bar" "baz" "foom").filter(|x| x.first.is_char())
  ;; remove-if-not は、つまりFilterのこと。よく使う。
#+end_src

#+RESULTS:
: (COUNT-IF #'EVENP #(1 2 3 4 5)) => 2
: (POSITION-IF #'DIGIT-CHAR-P "abcd0001") => 4
: (REMOVE-IF-NOT #'(LAMBDA (X) (CHAR= (ELT X 0) #\f)) #("foo" "bar" "baz" "foom")) => #("foo"
:                                                                                       "foom")

*** ソートとマージ
シーケンスをソートする関数は ~SORT~ と ~STABLE-SORT~ の2種類ある。いずれも、シーケンスと述語の2つの引数を取る。
#+begin_src lisp :results output
  (dbg (sort (vector "foo" "bar" "baz") #'string<))
#+end_src

#+RESULTS:
: (SORT (VECTOR "foo" "bar" "baz") #'STRING<) => #("bar" "baz" "foo")

~STABLE-SORT~ は、述語によって等価だと判断された要素同士の順序が入れ替わらない。元の順序が保存される。

ソート関数は破壊的関数の代表例で、引数のシーケンスを変更してしまう。よって、引数を利用せずに返り値を利用すること。
#+begin_src lisp :eval no
  ;; (sort my-sequence #'string<) 🙅
  
  (setf my-sequence (sort my-sequence #'string<)) 🙆
#+end_src

~MERGE~ 関数は2つのシーケンスと述語をとり、2つのシーケンスを述語に照らしつつマージする。
第1引数には生成されるシーケンスの型を指定する。
#+begin_src lisp :results output
  (dbg (merge 'vector #(1 3 5) #(2 4 6) #'<))
  (dbg (merge 'list #(1 3 5) #(2 4 6) #'<))
#+end_src

#+RESULTS:
: (MERGE 'VECTOR #(1 3 5) #(2 4 6) #'<) => #(1 2 3 4 5 6)
: (MERGE 'LIST #(1 3 5) #(2 4 6) #'<) => (1 2 3 4 5 6)

*** 部分シーケンス操作
既存のシーケンスの部分シーケンスを操作するための関数がいくつかある。一番基本的なのは ~SUBSEQ~ 。
PythonやRustのスライスに似た感じ。
#+begin_src lisp :results output
  (dbg (subseq "foobarbaz" 3))
  (dbg (subseq "foobarbaz" 3 6))
#+end_src

#+RESULTS:
: (SUBSEQ "foobarbaz" 3) => "barbaz"
: (SUBSEQ "foobarbaz" 3 6) => "bar"

シーケンスの中から部分シーケンスを検索するには ~SEARCH~ 関数を使う。
#+begin_src lisp :results output
  (dbg (search "bar" "foobarbaz"))
#+end_src

#+RESULTS:
: (SEARCH "bar" "foobarbaz") => 3

*** シーケンス述語
シーケンス全体に適用して真偽を評価するための述語関数が4つある。
~EVERY~, ~SOME~, ~NOTANY~, ~NOTEVERY~.

いずれも第1引数が述語で、残りの引数がシーケンスになる。
第1引数の述語は、残りの引数であるシーケンスの数と同じ数の引数を取るものでなければならない。
シーケンスの要素を全て使い果たすか、全体の終了条件を満たすまで、述語にはシーケンスの要素が1つずつ渡される。

#+begin_src lisp :results output
  (dbg (every #'evenp #(1 2 3 4 5)))
  (dbg (some #'evenp #(1 2 3 4 5)))
  (dbg (notany #'evenp #(1 2 3 4 5)))
  (dbg (notevery #'evenp #(1 2 3 4 5)))
  (terpri)
  (dbg (every #'> #(1 2 3 4) #(5 4 3 2)))
  (dbg (some #'> #(1 2 3 4) #(5 4 3 2)))
  (dbg (notany #'> #(1 2 3 4) #(5 4 3 2)))
  (dbg (notevery #'> #(1 2 3 4) #(5 4 3 2)))
  #+end_src

  #+RESULTS:
  : (EVERY #'EVENP #(1 2 3 4 5)) => NIL
  : (SOME #'EVENP #(1 2 3 4 5)) => T
  : (NOTANY #'EVENP #(1 2 3 4 5)) => NIL
  : (NOTEVERY #'EVENP #(1 2 3 4 5)) => T
  : 
  : (EVERY #'> #(1 2 3 4) #(5 4 3 2)) => NIL
  : (SOME #'> #(1 2 3 4) #(5 4 3 2)) => T
  : (NOTANY #'> #(1 2 3 4) #(5 4 3 2)) => NIL
  : (NOTEVERY #'> #(1 2 3 4) #(5 4 3 2)) => T

*** シーケンスマッピング関数
~MAP~ は上記シーケンス述語関数に似ていて、N個の引数を取る関数とN個のシーケンスを受け取る。
しかし ~MAP~ は真偽値ではなく、シーケンスの各要素に関数を適用した結果を含む新しいシーケンスを返す。
~CONCATENATE~ や ~MERGE~ のように、どんな種類のシーケンスを作るのか指定する必要がある。
#+begin_src lisp :results output
  (dbg (map 'vector #'* #(1 2 3 4 5) #(10 9 8 7 6)))
#+end_src

#+RESULTS:
: (MAP 'VECTOR #'* #(1 2 3 4 5) #(10 9 8 7 6)) => #(10 18 24 28 30)

~MAP-INTO~ というのもあり、これは新しいシーケンスを生成するのではなく、第1引数として渡したシーケンスに値を設定する。

もちろん、 ~REDUCE~ もある。アキュムレータはキーワード引数 ~:initial-value~ で設定する。
#+begin_src lisp :results output
  (dbg (reduce #'+ #(1 2 3 4 5 6 7 8 9 10) :initial-value 45))
#+end_src

#+RESULTS:
: (REDUCE #'+ #(1 2 3 4 5 6 7 8 9 10) :INITIAL-VALUE 45) => 100

** ハッシュテーブル
引数なしの ~MAKE-HASH-TABLE~ は、キーの等価を ~EQL~ によって判定するタイプのハッシュテーブルを作成する。
これはキーとして文字列を使う場合には問題になる。 ~EQL~ では2つの文字列が同じ内容か判別できない。
キーワード引数 ~:test~ に シンボル ~EQUAL~ を渡すと、 ~EQUAL~ によって判定するタイプのハッシュテーブルを作成できる。

ハッシュテーブルの要素にアクセスするには ~GETHASH~ 関数を使う。
#+begin_src lisp :results output
  (defparameter *h* (make-hash-table))

  (dbg (gethash 'foo *h*))
  (dbg (setf (gethash 'foo *h*) 'quux))
  (dbg (gethash 'foo *h*))
  #+end_src

  #+RESULTS:
  : (GETHASH 'FOO *H*) => NIL
  : (SETF (GETHASH 'FOO *H*) 'QUUX) => QUUX
  : (GETHASH 'FOO *H*) => QUUX

~GETHASH~ は多値を返却する。多値を利用するための ~MULTIPLE-VALUE-BIND~ マクロが提供されている。
#+begin_src lisp :results output
  ;; 直前のコードブロックに依存
  (defun show-value (key hash-table)
    (multiple-value-bind (value present) (gethash key hash-table)
        (if present
              (format nil "Value ~a actually present." value)
              (format nil "Value ~a because key not found." value))))

  (setf (gethash 'bar *h*) nil) ;NILを設定

  (dbg (show-value 'foo *h*))
  (dbg (show-value 'bar *h*))
  (dbg (show-value 'baz *h*))
  #+end_src

  #+RESULTS:
  : (SHOW-VALUE 'FOO *H*) => "Value QUUX actually present."
  : (SHOW-VALUE 'BAR *H*) => "Value NIL actually present."
  : (SHOW-VALUE 'BAZ *H*) => "Value NIL because key not found."


~REMHASH~ 関数でキーと値のペアを削除できるほか、 ~CLRHASH~ でハッシュテーブルを空にできる。

*** ハッシュテーブル上の反復
~MAPHASH~ は ~MAP~ に似た関数で、関数とハッシュテーブルをとり、ハッシュテーブル内のキーと値の各ペアに対して関数を呼び出す。
#+begin_src lisp :results output
  (maphash #'(lambda (k v) (format t "key: ~a value: ~a~%" k v)) *h*)
#+end_src

#+RESULTS:
: KEY: FOO VALUE: QUUX
: KEY: BAR VALUE: NIL

#+begin_src lisp :results output
  (defparameter *t* (make-hash-table))

  (setf (gethash 'zero *t*) 0)
  (setf (gethash 'ten *t*) 10)
  (setf (gethash 'hundred *t*) 100)

  (maphash #'(lambda (k v) (format t "key: ~a value: ~a~%" k v)) *t*)

  (terpri)

  (maphash #'(lambda (k v) (when (< v 10) (remhash k *t*))) *t*)
  (maphash #'(lambda (k v) (format t "key: ~a value: ~a~%" k v)) *t*)
  #+end_src

#+RESULTS:
: key: ZERO value: 0
: key: TEN value: 10
: key: HUNDRED value: 100
: 
: key: TEN value: 10
: key: HUNDRED value: 100

* 第12章 リスト処理：やつらがLISPと呼ぶ理由
** 「リストなんてない」
#+begin_quote
リストを理解する手がかりは、そのほとんどがより基本的なデータ型のインスタンスであるオブジェクトの上に構築された幻想だと理解することにある。
#+end_quote

リストは単純なオブジェクト: コンスセルの上に構築されている。
~CONS~ は2つの引数をとり、それら2つの値を保持する新しいコンスセルを返す。コンスセルは括弧の中に2つの値がドットで区切られたものとして印字される。
#+begin_src lisp :results output
  (dbg (cons 1 2))
#+end_src

#+RESULTS:
: (CONS 1 2) => (1 . 2)

2つの値には ~CAR~ と ~CDR~ でアクセスする。これらには ~SETF~ できる。
#+begin_src lisp :results output
  (dbg (car (cons 1 2)))
  (dbg (cdr (cons 1 2)))
  (terpri)

  (defparameter *cons* (cons 1 2))
  (dbg (setf (car *cons*) 10))
  (dbg *cons*)
#+end_src

#+RESULTS:
: (CAR (CONS 1 2)) => 1
: (CDR (CONS 1 2)) => 2
: 
: (SETF (CAR *CONS*) 10) => 10
: *CONS* => (10 . 2)


ある値がリストであるとは、それが ~NIL~ であるか他のコンスセルへの参照であるということ。
コンスセルの ~CAR~ はそのリストの最初の要素であり、 ~CDR~ は残りの要素を含む他のリスト（すなわち他のコンスセル、または ~NIL~ ）である。
Common Lispはこの約束事をわかっているので、このような「コンスセル鎖」をリストとして印字する。

#+begin_src lisp :results output
  (dbg (cons 1 nil))
  (dbg (cons 1 (cons 2 nil)))
  (dbg (cons 1 (cons 2 (cons 3 nil))))
#+end_src

#+RESULTS:
: (CONS 1 NIL) => (1)
: (CONS 1 (CONS 2 NIL)) => (1 2)
: (CONS 1 (CONS 2 (CONS 3 NIL))) => (1 2 3)


~LIST~ 関数は、これらの「コンスセル合成操作」を肩代わりしてくれる。
#+begin_src lisp :results output
  (dbg (list 1))
  (dbg (list 1 2))
  (dbg (list 1 2 3))
#+end_src

#+RESULTS:
: (LIST 1) => (1)
: (LIST 1 2) => (1 2)
: (LIST 1 2 3) => (1 2 3)

コンスセルではなくリストとして見ている時には、CARやCDRの代わりに ~FIRST~ と ~REST~ という同義語の方が合っている。
#+begin_src lisp :results output
  (defparameter *list* (list 1 2 3 4))
  (dbg (first *list*))
  (dbg (rest *list*))
  (dbg (first (rest *list*)))
#+end_src

#+RESULTS:
: (FIRST *LIST*) => 1
: (REST *LIST*) => (2 3 4)
: (FIRST (REST *LIST*)) => 2

コンスセルはどんな種類の値も保持できる。また、単一のリストに型の異なるオブジェクトを保持することもできる。
#+begin_src lisp
  (list "foo" (list 1 2) 10)
#+end_src

#+RESULTS:
| foo | (1 2) | 10 |

** リサイクルな関数と構造共有の組み合わせ
リスト操作関数には、引数のリスト構造の一部を、返り値と共有するような関数(構造共有)が存在する。
一方で、効率化のために 引数のリストを返り値にリサイクルするような関数もあり、これは構造共有と相性が悪い。

実践では、リサイクルな関数を使うときはお決まりのイディオムに従うことが多い。
よく利用するイディオムは、ローカル変数に保持されたリストに対して要素を ~PUSH~ していき、関数から返すときに ~NREVERSE~ するというもの。
#+begin_src lisp :results output
  (defun upto (max)
    (let ((result nil))
      (dotimes (i max)
        (push i result)) ;PUSH
      (nreverse result))) ;NREVERSE

  (dbg (upto 10))
#+end_src

#+RESULTS:
: (UPTO 10) => (0 1 2 3 4 5 6 7 8 9)

その次によく使われるイディオムは、リサイクルな関数の戻り値を、リサイクルされた値が含まれうる場所に即座に代入し直すというもの。
例えば、 ~REMOVE~ のリサイクルバージョンである ~DELETE~ を使ったものがある
#+begin_src lisp :results output
  (defparameter *foo* (list 1 nil 2 nil 3))
  (dbg *foo*)
  (terpri)
  (setf *foo* (delete nil *foo*))
  (dbg *foo*)
#+end_src

#+RESULTS:
: *FOO* => (1 NIL 2 NIL 3)
: 
: *FOO* => (1 2 3)

#+begin_quote
 リストを操作するときは一般に関数的なスタイルでコードを記述するのがベストだ。
 自分が書く関数は引数のリストの内容にだけ依存し、引数を変更しないようにしよう。
#+end_quote

** リスト操作関数
- ~SECOND~ から ~TENTH~ まで、序数の名前がついた関数が用意されている
- 汎用の ~NTH~ はインデックスとリストの2つの引数をとり、そのリストのゼロから数えてn番目の要素を返す。
- ~CAR~ と ~CDR~ の合成関数が28種類ある。caar, cadr, cadadr... ただこれらの関数はあまり頻繁に利用されない。

** マッピング
シーケンス用の ~MAP~ のほかに、リスト専用のマッピング関数が6つある。

~MAPCAR~ は戻り値が必ずリストになる ~MAP~ 。
#+begin_src lisp :results output
  (dbg (mapcar #'(lambda (x) (* 2 x)) (list 1 2 3)))
  (dbg (mapcar #'+ (list 1 2 3) (list 10 20 30)))
#+end_src

#+RESULTS:
: (MAPCAR #'(LAMBDA (X) (* 2 X)) (LIST 1 2 3)) => (2 4 6)
: (MAPCAR #'+ (LIST 1 2 3) (LIST 10 20 30)) => (11 22 33)

そのほか、
- ~MAPLIST~ はで関数に渡されるのがリストの要素ではなくコンスセルになる。
- ~MAPCAN~ と ~MAPCON~ は、それぞれ ~MAPCAR~ と ~MAPLIST~ に似た動作をするが、新しいリストを組み立てるのではなく関数の戻り値を ~NCONC~ で繋ぎ合わせる。
  - 具体的にいうと、mapcar は関数が返したリストをネストして追加するのに対し、mapcan はリストをネストせずにつなげ合わせる。
     #+begin_src lisp :results output
       (dbg (mapcar (lambda (x) (list (+ x 10) 'x)) '(1 2 3 4)))
       (dbg (mapcan (lambda (x) (list (+ x 10) 'x)) '(1 2 3 4))) 
     #+end_src

     #+RESULTS:
     : (MAPCAR (LAMBDA (X) (LIST (+ X 10) 'X)) '(1 2 3 4)) => ((11 X) (12 X) (13 X)
     :                                                         (14 X))
     : (MAPCAN (LAMBDA (X) (LIST (+ X 10) 'X)) '(1 2 3 4)) => (11 X 12 X 13 X 14 X)

- ~MAPC~ と ~MAPL~ は実際には制御構文で、いずれも最初のリスト引数をそのまま返す。つまりマップされる関数が副作用を伴う場合に使う。for-eachだね。

参考: https://devnull.hatenablog.jp/entry/2018/04/10/144746
        
* 第13章 リストを超えて: コンスセルの別用途
Common Lispには、コンスセルから構成されるデータ構造を、木や集合、ルックアップテーブルとして扱うための関数も用意されている。
** 木
木構造は、参照しているすべてのコンスセルを含んだバージョンの「リストのリスト」だと考えることができる。

「参照しているすべてのコンスセル」を含むか含まないかは、構造を複製するときに差異となって生じる。
~COPY-LIST~ 関数はメインのコンスセルのみをコピーし、参照しているコンスセルはコピーしない(ポインタを作成するだけ)。
一方 ~COPY-TREE~ 関数は参照しているコンスセルを含めて全てをコピーする(実体として複製する)。

~TREE-EQUAL~ は、木の構造が同じであり、かつ、葉が ~EQL~ によって等価とみなせるなら、真を返す。

これら以外で木を前提とした関数としては、シーケンス関数(~SUBSTITUTE~ や ~NSUBSTITUTE~ など)の木構造バージョンがある。

** 集合
どんなリストでも、集合として扱うことができる。Common Lispにはリストに対して集合論的な操作をする関数が備わっている。
ただしこれらの操作は、効率が良くない。

集合を組み立てるには ~ADJOIN~ 関数を使う。引数には集合に加えたいアイテムと、集合を表すリストをとり、アイテムを加えた新しい集合を返す。オリジナルのリストは変更しない。
モディファイマクロ ~PUSHNEW~ は、 ~ADJOIN~ の返り値を、リストの場所に ~setf~ したような動きをする。

集合に、あるアイテムが含まれているかどうかは ~MEMBER~, ~MEMBER-IF~, ~MEMBER-IF-NOT~ によってテストできる。

集合演算もサポートされていて、 ~INTERSECTION~, ~UNION~, ~SET-DIFFERENCE~, ~SET-EXCLUSIVE-OR~ が揃っている。これらの関数すべてに、先頭にNがつくリサイクルバージョンの関数がある。

** ルックアップテーブル : 連想リストと属性リスト
キーと値を対応させるテーブルもコンスセルから構築することができる。
コンスセルをベースとしたルックアップテーブルとしては、連想リスト(association list, alist)と属性リスト(property list, plist)の2種類ある。
大きなテーブルが欲しければハッシュテーブルを使った方がいいが、小さなテーブルとしてはこれらは便利に使える。

*** 連想リスト
連想リストは、各要素がキーと値のペアを表現したコンスセルを持っているようなリストになっている。
プリントすると、 ~((A . 1) (B . 2) (C . 3))~ のように印字される。

~ASSOC~ は連想リストのルックアップ関数で、キーと連想リストを引数に取る。最初にキーと一致したコンスセルを返す。
~:key~ や ~:test~ のキーワード関数も使える。
#+begin_src lisp :results output
  (defparameter *a* '((a . 1) (b . 2) (c . 3)))
  (dbg (assoc 'a *a*))
  (dbg (assoc 'c *a*))
  (dbg (assoc 'd *a*))
  (terpri)
  (dbg (cdr (assoc 'a *a*))) ;値を取り出す
#+end_src

#+RESULTS:
: (ASSOC 'A *A*) => (A . 1)
: (ASSOC 'C *A*) => (C . 3)
: (ASSOC 'D *A*) => NIL
: 
: (CDR (ASSOC 'A *A*)) => 1

連想リストの前に要素を追加するには、 ~CONS~ または ~ACONS~ を用いる。
#+begin_src lisp :results output
  (dbg (cons (cons 'new-key 'new-value) *a* ))
  (dbg (acons 'new-key 'new-value *a*))
#+end_src

#+RESULTS:
: (CONS (CONS 'NEW-KEY 'NEW-VALUE) *A*) => ((NEW-KEY . NEW-VALUE) (A . 1) (B . 2)
:                                           (C . 3))
: (ACONS 'NEW-KEY 'NEW-VALUE *A*) => ((NEW-KEY . NEW-VALUE) (A . 1) (B . 2)
:                                     (C . 3))

連想リストを変更するには上記関数を ~setf~ と組み合わせるか、 ~PUSH~ を使う。
#+begin_src lisp :results output
  (dbg (push (cons 'new-key 'new-value) *a*))
  (dbg *a*)
#+end_src

#+RESULTS:
: (PUSH (CONS 'NEW-KEY 'NEW-VALUE) *A*) => ((NEW-KEY . NEW-VALUE) (A . 1) (B . 2)
:                                           (C . 3))
: *A* => ((NEW-KEY . NEW-VALUE) (A . 1) (B . 2) (C . 3))

~COPY-ALIST~ 関数で連想リストのコピーができる。
~PAIRLIS~ 関数は、キーのリストと値のリストから、1つの連想リストを作ることができる。

*** 属性リスト
属性リストはキーと値が交互に並んでいるもので、構造としては普通のリストと何も変わらない。
連想リストでいう ~((A . 1) (B . 2) (C . 3))~ は属性リストでは ~[A 1 B 2 C 3]~ となる。

属性リストをルックアップする関数は ~GETF~ しかない。
~SETF~ と ~GETF~ を組み合わせれば、あるキーに対応する値を設定することができる。
#+begin_src lisp :results output
  (defparameter *plist* ())
  (dbg *plist*)
  (setf (getf *plist* :a) 1)
  (dbg *plist*)
  (setf (getf *plist* :a) 2)
  (dbg *plist*)
#+end_src

#+RESULTS:
: *PLIST* => NIL
: *PLIST* => (:A 1)
: *PLIST* => (:A 2)

属性リストからキーと値のペアを取り除くには、 ~REMF~ マクロを使う。
#+begin_src lisp :results output
  (dbg (remf *plist* :a))
  (dbg *plist*)
#+end_src

#+RESULTS:
: (REMF *PLIST* :A) => T
: *PLIST* => NIL

~GET-PROPERTIES~ という、一つの属性リストから複数の属性を取り出せる関数もある。

Common Lispでは、どんなシンボルオブジェクトにも専用の属性リストがあって、そのシンボルについての情報を格納するために使うことができる。
その属性リストは ~SYMBOL-PLIST~ 関数によって取得でき、また特定の属性についてはキーを引数に取る ~GET~ 関数で取得できる。
シンボルの属性リストからある属性を取り除きたかったら、 ~REMPROP~ を使う。

* 第14章 ファイルとファイルI/O
Common Lispではファイルを扱うために、ストリームの抽象と、OS独自のファイル名の扱いを処理するための抽象が用意されている。

** ファイルオープン
~OPEN~ 関数でファイルの内容を読むストリームを得ることができる。ストリームを閉じるには ~CLOSE~ を使う。
1文字読み込む ~READ-CHAR~ や、行を読み込んで行末文字をのぞいた文字列を返す ~READ-LINE~ や、S式を読み込みLispオブジェクトを返す ~READ~ などが、入力ストリームを受け付ける。

ファイルの最初の行を印字するには、以下のようにする。
#+begin_src lisp :results output
 (let ((in (open "./practical-common-lisp.org")))
   (format t "~a~%" (read-line in))
   (close in))
#+end_src

#+RESULTS:
: **実践Common  lisp**

読み込みに失敗した場合、 ~OPEN~ 関数と ~READ-*~ 関数はデフォルトでエラーを通知する。例外をハンドリングすることもできるが、追加の引数を渡すことで、例外が発生した時の関数の振る舞いを帰ることができる。
存在しないファイルを開こうとしたときにエラーを通知しないようにするには、 ~:if-does-not-exist~ を使って異なる挙動を支持できる。デフォルトの ~:error~ と、エラーの代わりにファイルを作成する ~:create~ 、NILを返す ~NIL~ から選べる。
ファイルの全行を印字するには、:if-does-not-existにNILをつけて次のようにする。
#+begin_src lisp :results output
 (let ((in (open "./my-cds.db" :if-does-not-exist nil)))
   (when in
     (loop for line = (read-line in nil)
           while line do (format t "~a~%" line))
     (close in)))
#+end_src

#+RESULTS:
: 
: ((:TITLE "Perfume The Best 'P Cubed'" :ARTIST "Perfume" :RATING 9 :RIPPED T) (:TITLE "NewJeans 2nd EP 'Get Up'" :ARTIST "NewJeans" :RATING 7 :RIPPED T) (:TITLE "条理加速の片隅、彼女と想像の中身に関する行方 EP" :ARTIST "gaburyu" :RATING 8 :RIPPED T) (:TITLE "懐かしい月は新しい月" :ARTIST "サカナクション" :RATING 10 :RIPPED T) (:TITLE "Sakanaction" :ARTIST "サカナクション" :RATING 10 :RIPPED T) (:TITLE "Beyond The Binary" :ARTIST "星宮とと, SOZEN OTSUBO" :RATING 7 :RIPPED T)) 


** 読み込み
~READ~ はLispのソースを読み込むことができる。 ~PRINT~ と合わせて使えば、ファイルがちょっとしたDBになる。

~READ-SEQUENCE~ は文字ストリームにもバイナリストリームにも使うことができる。この関数にシーケンスとストリームを渡すと、ストリームから読み出したデータでシーケンスを埋めていこうとする。そして、埋められなかった分のシーケンスの最初の要素のインデックスか、埋められた場合はシーケンスの長さを返す。
~READ-BYTE~ や ~READ-CHAR~ よりも効率がいい。

バイナリデータを読み込むには、 ~OPEN~ の ~:element-type~ 引数に ~'(unsigned-byte 8)~ を渡す。この結果のストリームは、 ~READ-BYTE~ 関数に渡すことができる。

** ファイル出力
出力ストリームは、キーワード引数 ~:direction~ を ~:output~ にして ~OPEN~ を呼び出せば得られる。
ファイルを出力用に開くときは、そのファイルはまだ存在していないと仮定する。もし存在していたらエラーを通知するが、この挙動はキーワード引数 ~:if-exists~ によって変えられる。この引数を ~:supersede~ にすると既存のファイルを置き換えるようになる。そのほかに ~:append~ や ~:overwrite~ がある。

データを書き出す関数はいくつかある。 ~WRITE-CHAR~ は1文字をストリームに書き出す。 ~WRITE-LINE~ は行を書き出す。 ~WRITE-STRING~ は文字列を書き出すが、行末文字は書き出さない。 ~WRITE-SEQUENCE~ はまとめ書きもできる。

空行を書き出すには、強制的に改行する ~TERPRI~ (terminate print) や、ストリームが行頭にいるとき以外は改行を印字する ~FRESH-LINE~ が使える。

いくつかの関数はLispのデータをS式として出力する。 ~PRINT~ はS式を改行コードの後に印字し、その後ろにスペースを印字する。 ~PRIN1~ はS式だけを印字する。 ~PPRINT~ はS式をできるだけ美しく印字する。 ~PRINC~ もLispのオブジェクトを印字するが、こちらは人間が読むことを意図している。DebugがPRINCでDisplayがPRINTって感じか。

バイナリデータを書き出すときは、読み込みと同じように ~OPEN~ の ~:element-type~ 引数に ~'(unsigned-byte 8)~ を渡す。

** ファイルクローズ
~CLOSE~ 関数でストリームを閉じられるが、ほとんど使われない。
代わりにファイルクローズには ~WITH-OPEN-FILE~ マクロを利用する。このマクロは特殊オペレータ ~UNWIND-PROTECT~ を利用して作られている。
#+begin_src lisp :noeval
  (with-open-file (stream-var open-argument*)
    body-form*)
#+end_src
この中では、 ~open-argument~ を引数とした ~OPEN~ で開いたファイルストリームを ~stream-var~ に束縛した状態で、 ~body-form~ が評価される。

クローズも含めて、ファイルから1行読み込むには以下のように書く。
#+begin_src lisp :results output
  (with-open-file (stream "./practical-common-lisp.org")
    (format t "~a~%" (read-line stream)))
#+end_src

#+RESULTS:
: **実践Common  lisp**

新しいファイルを作るには以下のようにする。
#+begin_src lisp :results output
  (dbg (with-open-file (stream "somefile.txt" :direction :output :if-exists :overwrite)
     (format stream "Some text.")))
#+end_src

#+RESULTS:
: (WITH-OPEN-FILE
:     (STREAM "somefile.txt" :DIRECTION :OUTPUT :IF-EXISTS :OVERWRITE)
:   (FORMAT STREAM "Some text.")) => NIL

** パスネームオブジェクト
WINとMACの間などでのパス名の互換をとるために、Commmon Lispにはパスネームオブジェクトが用意されている。
歴史的な経緯からパスネームオブジェクトには過剰に複雑な面があるが、必要のない箇所は無視して良い。
ファイル名が求められる箇所では 文字列・パスネームオブジェクト・ストリーム の3つのうちどれかを使うことができる。これらは ~パスネーム指示子~ と呼ばれる。

名前文字列からパスネームへの変換には ~PATHNAME~ 関数を使う。この関数はパスネーム指示子を受け取り、それと等価なパスネームオブジェクトを返す。

パスネーム(オブジェクト)は、ホスト、デバイス、ディレクトリ、ネーム、タイプ、それにバージョンという6つの要素を使ってファイル名を表現する。
これらの要素のうち、ディレクトリだけはリスト構造だが、大半はアトミックな値(文字列)になっている。
*全てのプラットフォームで全ての要素が必要になるわけではない。* 組み込みの実装に任せるか、既存のパスネームから大半の要素を流用すれば良い。
例えばUnixファイルシステムではディレクトリとネームとタイプだけ使われる。Windowsではそれに加えて、ドライブ名を保持するためにデバイスまたはホストが使われる。

パスネームの個々の要素は、 ~PATHNEMA-DIRECTORY~ や ~PATHNAME-NAME~ 、 ~PATHNAME-TYPE~ といった関数で調べることができる。
#+begin_src lisp :results output
  (dbg (pathname-directory (pathname "/Users/gomadoufu/.emacs.d/init.el")))
  (dbg (pathname-directory (pathname "../../../../.emacs.d/init.el")))
  (dbg (pathname-name (pathname "/Users/gomadoufu/.emacs.d/init.el")))
  (dbg (pathname-type (pathname "/Users/gomadoufu/.emacs.d/init.el")))
#+end_src

#+RESULTS:
#+begin_example
(PATHNAME-DIRECTORY (PATHNAME "/Users/gomadoufu/.emacs.d/init.el")) => (:ABSOLUTE
                                                                        "Users"
                                                                        "gomadoufu"
                                                                        ".emacs.d")
(PATHNAME-DIRECTORY (PATHNAME "../../../../.emacs.d/init.el")) => (:RELATIVE
                                                                   :UP :UP :UP
                                                                   :UP
                                                                   ".emacs.d")
(PATHNAME-NAME (PATHNAME "/Users/gomadoufu/.emacs.d/init.el")) => "init"
(PATHNAME-TYPE (PATHNAME "/Users/gomadoufu/.emacs.d/init.el")) => "el"
#+end_example

パスネームの文字列表現は、 ~#p~ 文字列を続けたものとなっている。
#+begin_src lisp :results output
  (dbg (pathname "/foo/bar/baz.txt"))
#+end_src

#+RESULTS:
: (PATHNAME "/foo/bar/baz.txt") => #P"/foo/bar/baz.txt"


パスネームを名前文字列に戻すには、 ~NAMESTRING~ 関数を使う。亜種として、 ~DIRECTORY-NAMESTRING~ と ~FILE-NAMESTRING~ がある。
#+begin_src lisp :results output
  (dbg (namestring #p"/foo/bar/baz.txt"))
  (dbg (directory-namestring #p"/foo/bar/baz.txt"))
  (dbg (file-namestring #p"/foo/bar/baz.txt"))
#+end_src

#+RESULTS:
: (NAMESTRING #P"/foo/bar/baz.txt") => "/foo/bar/baz.txt"
: (DIRECTORY-NAMESTRING #P"/foo/bar/baz.txt") => "/foo/bar/"
: (FILE-NAMESTRING #P"/foo/bar/baz.txt") => "baz.txt"

~MAKE-PATHNAME~ 関数を使って任意のパスネームを作ることができる。
*ただし移植性のあるプログラムにしたかったら、こんなふうにパスネームをゼロから作ったりしないほうがいい。
#+begin_src lisp
  (make-pathname
     :directory '(:absolute "foo" "bar")
     :name "baz"
     :type "txt")
#+end_src

#+RESULTS:
: #P"/foo/bar/baz.txt"

パスネームはゼロから作らなくても、 ~MAKE-PATHNAME~ にキーワード引数 ~:defaults~ を指定して、すでにあるパスネームを元に作ることができる。
例えば以下の式は、.htmlという拡張子を持ち、それ以外の要素はinput-fileと同じパスネームを作る。
#+begin_src lisp :eval no
  (make-pathname :type "html" :defaults input-file)
#+end_src

~MERGE-PATHNAMES~ はパスネームを2つとり、1つめのパスネームの中で ~NIL~ な要素を2爪のパスネームの対応する値で埋めることで、パスネーム同士をマージする。

** ファイルシステムとのやりとり
パスネーム指示子に対応するファイルがファイルシステム上に存在するかどうかを調べるには、 ~PROBE-FILE~ を使う。

ファイルシステムのファイルを列挙するには ~DIRECTORY~ を使う。

ファイルの削除には ~DELETE-FILE~ を、名前の変更には ~RENAME-FILE~ を使う。

~ENSURE-DIRECTORIES-EXIST~ 関数を使ってディレクトリを作ることができる。

関数 ~FILE-WRITE-DATE~ は、最後にファイルが書き込まれた時間を1900年1月1日のグリニッジ標準時から経過した秒数の形をした数値として返す。 ~FILE-AUTHOR~ はファイルの所有者を返す。

Cのシステムコールへのバインディングライブラリがある！ https://github.com/osicat/osicat?tab=readme-ov-file

** そのほかのI/O
ファイルストリーム以外にも、Common Lispではたくさんの種類のストリームが提供されている。

文字列ストリーム ~STRING-STREAM~ は、 ~MAKE-STRING-INPUT-STREAM~ と ~MAKE-STRING-OUTPUT-STREAM~ を使って作ることができる。
~MAKE-STRING-OUTPUT-STREAM~ から文字列を取り出すには ~GET-OUTPUT-STREAM-STRING~ 関数を使う。
WITH版の ~WITH-INPUT-FROM-STRING~ と ~WITH-OUTPUT-TO-STRING~ があるので、結局こっちの方が便利だったりする。
#+begin_src lisp
  (with-input-from-string (s "1.23")
    (read s))
#+end_src

#+RESULTS:
: 1.23

#+begin_src lisp
  (with-output-to-string (out)
    (format out "hello, world ")
    (format out "~s" (list 1 2 3)))
#+end_src

#+RESULTS:
: hello, world (1 2 3)


そのほかにも、ストリーム同士をつなげる「配管」役として
- ~BROADCAST-STREAM~
- ~CONCATENATED-STREAM~
- ~TWO-WAY-STREAM~
- ~ECHO-STREAM~
がある。

ネットワークAPIについては、標準では何も決められていない。

* 第15章 実践：パスネーム可搬ライブラリ
** 実装依存のコードを書く方法
実装に依存したコードを書くには、*読み込み時条件分岐* を使う。この機構には、変数 ~*FEATURES*~ と2種類の専用シンタックスを使う。
~*FEATURES*~ はシンボルのリストで、各シンボルが現在の処理系の機能(feature)を示している。featureにはシンボルのものと、式のものがある。

Lispの読み取り機でfeatureを読み込むときには、 ~#+~ および ~#-~ というシンタックスを使う。 ~#+~ に続く機能式が真であれば、読み取り機は続く式を普通に読み込む。そうでなければ無視する。 ~#-~ は機能式が偽の時に読み込み、真の時は無視する。

これらを使って、以下のような処理系ごとに異なる処理をする関数を書ける
#+begin_src lisp :eval no
  (defun foo ()
    #+allegro (do-one-thing)
    #+sbcl (do-another-thing)
    #+clisp (something-else)
    #-(or allegro sbcl clisp) (error "Not implemented"))
#+end_src

* 第16章 オブジェクト指向再入門：総称関数
** 総称関数とクラス
- 他の多くの言語と同じく、Common Lispもクラス志向
- クラス階層があり、トップは ~Tクラス~ 。値としての ~T~ とは関係がない。
- Common Lispは多重継承を許す。
- 昔、Lispに実装されていたメッセージパッシングと一般的なメソッド呼び出しのシンタックスを統合しようという動きがあり、 ~総称関数~ が生まれた。

** 総称関数とメソッド
総称関数は抽象的な操作を定義する。定義では、操作の名前とパラメータのリストを指定するが、実装は指定しない。C言語のヘッダみたいなものか。
#+begin_src lisp
  (defgeneric draw (shape)
    (:documentation "スクリーン上に指定された図を描く"))
#+end_src
総称関数は、引数としてどんなオブジェクトでも受け入れる。
総称関数の定義は、メソッドによって提供される。メソッドはクラスではなく総称関数に紐付けられる。ここがJavaやC++と大きく異なる点。

メソッドがどんな種類の引数を扱えるかは、総称関数で定義された必須パラメータがメソッドを定義するときに特定化されることで決まる。
例えば総称関数 ~draw~ に対し、 ~shape~ パラメータを ~circle~ クラスのインスタンスに特定化したメソッドが定義できる。あるいは、 ~shape~ パラメータを ~traiangle~ クラスのオブジェクトに特定化したメソッドも定義できる。
#+begin_src lisp :eval no
  (defmethod draw ((shape circle))
    ;unimplemented
    )

  (defmethod draw ((shape triangle))
    ;unimplemented
    )
#+end_src
総称関数を呼び出すと、渡した引数が各メソッドの引数と比較され、適用可能なメソッドが選ばれる。適用可能なメソッドが複数見つかった場合は、それらのショルが統合されて1つの適用可能なメソッドになる。

メソッドにおいて、どんなオブジェクトが適用可能であるかを指定する方法は2種類ある。通常は特定子としてクラスを指定する。または、 ~EQL~ 特定子という特殊な特定子を利用できる。

** メソッド結合
メソッドには ~CALL-NEXT-METHOD~ 呼び出しを書くことができる。総称関数は呼び出されると、適用可能なメソッドを組み合わせて実効メソッドを組み立てるが、この際 ~CALL-NEXT-METHOD~ ではメソッド結合が起こる。

#+begin_quote
  適用可能なメソッドを組み合わせて実行メソッドを組み立てるという概念は、総称関数のコンセプトの肝になるものだ。
#+end_quote

実効メソッドは3つのステップで作られる。
1. 総称関数が、実引数に基づいて、適用可能なメソッドのリストを作る。
2. メソッドの特定子に応じて、適用可能メソッドのリストが並べ替えられる
3. 並び替えられたリストの順番にメソッドが選ばれ、実効メソッドを作るためにコードが結合される。

特定子がクラスの名前の場合は、メソッドの実引数のクラスがその名前か、またはいずれかのスーパークラスがその名前である場合に適合する。 ~EQL~ 特定子は、引数が特定子と同じオブジェクトの場合のみ適合する。
2つ以上のパラメータを明示的に特定化したメソッドは *多重メソッド* と呼ばれる。

適用可能なメソッドは実効メソッドとして組み合わされる前に、特定子が詳細なものが前に来るように並び替えられる。典型的なのは、クラスで指定された2つの特定子が異なっている場合に、片方が他方のサブクラスになっている場合で、この場合はサブクラスの名前で特定化している方が、より詳細な特定子だとみなされる。 ~EQL~ 特定子は、クラスで指定されたどの特定子よりも詳細ということになっている。

** 標準メソッド結合
メソッド結合のデフォルトのアルゴリズムを、 *標準メソッド結合* という。標準メソッド結合では最も特定的なメソッドが最初に実行され、 ~CALL-NEXT-METHOD~ を通じて次に特定的なメソッドに制御が移っていく。

これまでに出てきたメソッドは *基本メソッド* と呼ばれるが、標準メソッド結合ではこのほかに *補助メソッド* として ~:before~, ~:after~, ~:around~ に対応している。 ~:before~ は最も特定的な基本メソッドより前に実行される。このため、 ~:before~ メソッドは実行環境を準備する作業に使うことができる。
~:after~ メソッドは、全部の基本メソッドが特定度順で実行されたあとに実行される。 ~:around~ メソッドは ~:before~ メソッドよりもさらに前に実行される。 ~:around~ メソッドは自動的にスーパークラスの ~:around~ メソッドや基本メソッドを呼び出すことをしない。

補助メソッドは、便利なシンタックスにすぎず、基本メソッドの結合でできないことができるようになるわけではない。補助メソッドはライブラリに柔軟性を持たせてくれている。

** そのほかのメソッド結合
標準メソッド結合に加えて、言語使用では ~+,AND,OR,LIST,APPEND,NCONC,MIN,MAX,PROGN~ の9種類の組み込みメソッド結合が定義されている。これらは *単純組み込みメソッド結合* と呼ばれる。単純組み込みメソッド結合では、基本メソッドのコードを1つずつ含む実行メソッド全体を、関数・マクロ・特殊オペレータの呼び出しでくるむ。たとえば ~+~ メソッド結合を使う総称関数は、その基本メソッドが返す全ての結果の総和を返す。

特定のメソッド結合を使った総称関数を定義するには、 ~:method-combination~ オプションを ~DEFGENERIC~ フォームに含める。
#+begin_src lisp :eval no
  (defgeneric priority (job)
    (:documentation "jobが実行される優先度を返す")
    (:method-combination +))
#+end_src


単純組み込みメソッド結合を使う総称関数では、基本メソッドはメソッド結合の名前で修飾されていなければならない。
#+begin_src lisp :eval no
  (defmethod priority + ((job express-job)) 10)
#+end_src

単純組み込みメソッド結合では、基本メソッドと、 ~:around~ メソッドの2つだけに対応している。

とはいえ、ほとんど標準メソッドで済むとのこと。
#+begin_quote
要するに、99%の場合は標準メソッド結合で十分だ。残りの1%農地、さらに99%の場合は、単純組み込みメソッド結合をどれか1つ使って対応できる。どの組み込み結合でも満足できない1%のそのまた1%の場合には、お好きなCommon Lispのリファレンスから ~DEFINE-METHOD-COMBINATION~ を参照すればいい。
#+end_quote

* 第17章 オブジェクト指向再入門：クラス

** DEFCLASS
ユーザ定義クラスは ~DEFCLASS~ マクロを使って作ることができる。 ~DEFCLASS~ が担当するのはクラスをデータ型として定義する部分のみで、振る舞いの方は総称関数およびクラスに特定化されたメソッドが担う。

クラスにはデータ型としての3つの側面がある。
- 名前
- ほかのクラスとの関係
- クラスのインスタンスが持つスロット(フィールド・メンバ変数)の名前

#+begin_src lisp :eval no
  (defclass name (direct-superclass-name*)
    (slot-specifier*))
#+end_src
~direct-superclass-name~ にはスーパークラスを指定する。複数指定することもできる(多重継承)。ひとつも指定しなかった場合、そのクラスは ~STANDARD-OBJECT~ の直接のサブクラスになる。 ~SANDARD-OBJECT~ は ~Tクラス~ のサブクラス。

** スロット指定子
スロット指定子は、そのクラスのインスタンスの一部となるスロットを定義する。スロットは値を保持できる場所で、 ~SLOT-VALUE~ 関数を使ってアクセスする。 ~SLOT-VALUE~ は引数としてオブジェクトとスロットの名前を取り、与えられたオブジェクトの指定されたスロットの値を返す。この返された値は ~SETF可能~ である。
#+begin_src lisp
  (defclass bank-account ()
    (customer-name
     balance))
  (make-instance 'bank-account)
#+end_src

#+RESULTS:
: #<BANK-ACCOUNT {10010F67D3}>

このインスタンスのスロットにはまだ値が設定されていないので、読み込むには値を設定する必要がある。
#+begin_src lisp :results output
  (defparameter *account* (make-instance 'bank-account))
  (setf (slot-value *account* 'customer-name) "John Doe")
  (setf (slot-value *account* 'balance) 1000)

  (dbg (slot-value *account* 'customer-name))
  (dbg (slot-value *account* 'balance))
#+end_src

#+RESULTS:
: (SLOT-VALUE *ACCOUNT* 'CUSTOMER-NAME) => "John Doe"
: (SLOT-VALUE *ACCOUNT* 'BALANCE) => 1000

** オブジェクトの初期化
スロットの値をオブジェクト生成時に初期化するのに、3種類の方法が用意されている。
1. ~DEFCLASS~ のスロット指定子に ~:initarg~ オプションを使って名前を指定しておき、 ~MAKE-INSTANCE~ で初期値を設定する
2. 同じくスロット指定子に ~:initform~ でLisp式を設定する
3. ~MAKE-INSTANCE~ の際に裏で呼ばれている総称関数 ~INITIALIZE-INSTANCE~ に対するメソッドを定義して、初期化を制御する


#+begin_src lisp :results output
  (defclass bank-account ()
    ((customer-name
      :initarg :customer-name)
     (balance
      :initarg :balance
      :initform 0)))

  (defparameter *account*
    (make-instance 'bank-account :customer-name "John Doe" :balance 1500))
  (dbg (slot-value *account* 'customer-name))
  (dbg (slot-value *account* 'balance))
#+end_src

#+RESULTS:
: (SLOT-VALUE *ACCOUNT* 'CUSTOMER-NAME) => "John Doe"
: (SLOT-VALUE *ACCOUNT* 'BALANCE) => 1500


~INITIALIZE-INSTANCE~ に対して ~:after~ メソッドを定義することで、コンストラクタのような独自の初期化機構を追加することができる。
#+begin_src lisp :results output
  (defparameter *account-numbers* 0)

  (defclass bank-account ()
    ((customer-name
      :initarg :customer-name
      :initform (error "Must supply a customer name."))
     (balance
      :initarg :balance
      :initform 0)
     (account-number
      :initform (incf *account-numbers*))
     account-type))

  ;; 初期化用の総称関数にカスタムの補助メソッドを定義すると、コンストラクタのように使える
  (defmethod initialize-instance :after ((account bank-account) &key)
    (let ((balance (slot-value account 'balance)))
      (setf (slot-value account 'account-type)
            (cond
              ((>= balance 100000) :gold)
              ((>= balance 50000) :silver)
              (t :bronze)))))

  (dbg (slot-value (make-instance 'bank-account :customer-name "Sally Sue" :balance 1000) 'account-type))
  (dbg *account-numbers*)
  (dbg (slot-value (make-instance 'bank-account :customer-name "Jonh Doe" :balance 100000) 'account-type))
  (dbg *account-numbers*)
#+end_src

#+RESULTS:
: (SLOT-VALUE
:  (MAKE-INSTANCE 'BANK-ACCOUNT :CUSTOMER-NAME "Sally Sue" :BALANCE 1000)
:  'ACCOUNT-TYPE) => :BRONZE
: *ACCOUNT-NUMBERS* => 1
: (SLOT-VALUE
:  (MAKE-INSTANCE 'BANK-ACCOUNT :CUSTOMER-NAME "Jonh Doe" :BALANCE 100000)
:  'ACCOUNT-TYPE) => :GOLD
: *ACCOUNT-NUMBERS* => 2


** アクセサ関数
他のオブジェクト指向言語と同様に、アクセス関数はクラスとコードを疎結合にする。

balanceスロットの値をを読み込むようなゲッタメソッドを定義すると以下のようになる。拡張性のために、総称関数も定義しておく。
#+begin_src lisp
  (defgeneric balance (account))

  (defmethod balance ((account bank-account))
    (slot-value account 'balance))
#+end_src

#+RESULTS:
: #<STANDARD-METHOD COMMON-LISP-USER::BALANCE (BANK-ACCOUNT) {1003EC2703}>

セッタは、 ~SETF関数~ として定義するのが最適。 ~SETF関数~ というのは ~SETF~ マクロを拡張する方法で、関数が設定方法を知っているような保存場所を新しく定義できる。 ~SETF関数~ の名前は2つのシンボルのリストで、シンボル ~SETF~ と設定場所へのアクセス関数の名前からなる。
例えば、bank-accountのcustomer-nameスロットに値を設定する ~SETF関数~ は次のようにして定義できる。
#+begin_src lisp
  (defgeneric (setf customer-name) (value account))

  (defmethod (setf customer-name) (value (account bank-account))
    (setf (slot-value account 'customer-name) value))
#+end_src

#+RESULTS:
: #<STANDARD-METHOD (COMMON-LISP:SETF COMMON-LISP-USER::CUSTOMER-NAME) (T
:                                                                       BANK-ACCOUNT) {1000CD63C3}>

この定義を評価した後では、以下のような形の式は、
#+begin_src lisp :eval no
  (setf (customer-name my-account) "Sally Sue")
#+end_src
1つめの引数が"Sally Sue"で2つめの式数がmy-accountの値であるような ~SETF関数~ の呼び出しとしてコンパイルされる。
ゲッタも書くと、こんな感じ。
#+begin_src lisp :results output
  (defgeneric customer-name (account))

  (defmethod customer-name ((account bank-account))
    (slot-value account 'customer-name))

  (defparameter *acct* (make-instance 'bank-account :customer-name "acct" :balance 60000))
  (dbg (customer-name *acct*))
  (terpri)
  (dbg (setf (customer-name *acct*) "Sally Sue"))
  (dbg (customer-name *acct*))
#+end_src

#+RESULTS:
: (CUSTOMER-NAME *ACCT*) => "acct"
: 
: (SETF (CUSTOMER-NAME *ACCT*) "Sally Sue") => "Sally Sue"
: (CUSTOMER-NAME *ACCT*) => "Sally Sue"


これらのアクセサを書くのはそんなに大変ではないが、手で書くのはナンセンス。そこで ~DEFCLASS~ に自動生成させることができる！(最高！)
~:reader~ オプションに名前を指定するとゲッタを生成してくれる。
~:writer~ オプションにはリストを渡すことができ、1つめの引数として新しい値をとり、その場所を結果として返す。これは ~SETF関数~ と同じなので、結局 ~SETF関数~ と同じようにかけばいい。
最後に、これらを両方とも生成する ~:accessor~ オプションと、スロットに説明をつける ~:documentation~ オプジョンが用意されている。
#+begin_src lisp
  (defclass bank-account ()
    ((customer-name
      :initarg :customer-name
      :initform (error "Must supply a customer name.")
      :accessor customer-name
      :documentation "顧客名")
     (balande
       :initarg :balance
       :initform 0
       :reader balance)
     (account-number
      :initform (incf *account-numbers*))
     (account-type
      :reader account-type
      :documentation "口座種別。 :gold, :silver, :bronzeのいずれか")))
#+end_src

** WITH-SLOTS と WITH-ACCESSORS
#+begin_quote
アクセサ関数を使うとコードはメンテナンスしやすくなるが、まだ冗長だ。そしてクラスの低レベルな振る舞いを実装するメソッドの実装を書いている時には、書き込み関数のないスロットを設定するのに直接アクセスしたいこともあれば、読み込み関数の上に定義されている補助的なメソッドを実行せずにスロットの値を取得したいこともあるだろう。
#+end_quote

この用途のために、 ~WITH-SLOTS~ と ~WITH-ACCESSORS~ というマクロが役に立つ。どちらもブロックを作り、その中ではスロットをシンプルな変数名で参照できるようになる。 ~WITH-SLOTS~ の方はスロットへの直接アクセスを提供し、 ~WITH-ACCESSORS~ では変数への参照がアクセサメソッドの呼び出しに置き換わる。
#+begin_src lisp :eval no
  (defmethod assess-low-balance-penalty ((account bank-account))
    (with-slots (balance #|スロット名&変数名|#) account
      (when (< balance *minimum-balance*)
        (decf balance (* balance .01) #|普通に参照できる|#))))
#+end_src

balanceの定義で ~:reader~ ではなく ~:accessor~ を使っていたなら、 ~WITH-ACCESSORS~ を使うこともできる。
#+begin_src lisp :eval no
  (defmethod merge-accounts ((account1 bank-account) (account2 bank-account))
    (with-accessors ((balance1 balance)) account1
      (with-accessors ((balance2 balance)) account2
        (incf balance1 balance2 #|普通に参照できる|#)
        (setf balance2 0 #|普通にsetfできる|#))))
#+end_src

~WITH-SLOTS~ を使うか ~WITH-ACCESSORS~ を使うかの基準は、スロットに直接アクセスするのかアクセサメソッドを使うのかの判断基準と同じ。
基本は ~WITH-ACCESSORS~ を使う。


** 共有スロット、スロットと継承
スロットに ~:allocation~ オプションを指定すると、値をクラスに格納する ~:class~ かインスタンスに格納する(デフォルト動作) ~:instance~ か選べる。ただし ~:class~ スロットの値も、インスタンス経由でしかアクセスできない。この点はJavaやC++のstaticフィールドとは異なる。 ~:allocation~ はスペースの節約になる程度。

クラスは、振る舞いをスーパークラスから継承するときに、総称関数の機構を使う。スロットもスーパークラスから継承されるが、仕組みは少し違う。
Common Lispでは *新しいクラスとその全スーパークラスから同じ名前の指定子をすべてマージして、ユニークなスロット名ごとに指定子を1つ生成する。* スロットオプションが別のスロットは別のものとみなす。

** 多重継承
Common Lispは多重継承をサポートしている。普通はあまり問題にならないが、総称関数の実行メソッドを生成するときに、クラスの特定化がややこしくなる。

クラスにスーパークラスが複数ある場合には、「サブクラスの方がスーパークラスより特定的」というルールだけではメソッドの結合順を並べ替えることができない。そこでルールを1つ追加して、「 ~DEFCLASS~ フォームのリストで先に出てくるものがより特定的」ということになっている。
ちなみにスロットのマージの際には、同じ名前を持つスロット指定子はすべてマージされるので、同じスロットを何度継承していても問題ない。要するに、 *Common Lispでは菱形継承問題が起きない。*

* 第18章 FORMATの手習い

** 引数
1つめの引数は出力先
- T ... ~*STANDARD-OUTPUT*~ の短縮形
- NIL ... 出力が文字列になって返る
- ストリーム ... そのストリームに対して出力される
- フィルポインタ付きの文字列 ... 文字列の最後にフォーマットの出力が追加され、フィルポインタが変更される

2つめの引数は制御文字列。専用のDSLで書く。 *理解のしやすさよりも短く書けることが主眼に置かれている。*

** FORMAT関数の指示子
*全ての指示子はチルダで始まり、指示子を表す1つの文字で終わる。* この文字は大文字で書いても小文字で書いてもいい。

指示子によっては前置パラメータを取るものがあり、これはチルダのすぐ後にカンマ区切りで置く。
前置パラメータは数値か、シングルクォートに続けて書いた文字で、フォーマット引数から生成することもできる。
引数から前置パラメータを生成するには ~V~ を使って引数を前置パラメータとして消費するか、 ~#~ で残りのフォーマット引数の個数を前置パラメータとして取得する方法がある。
#+begin_src lisp :results output verbatim
  (format t "~v$" 3 pi)
  (terpri)
  (format t "~#$" pi)
#+end_src

#+RESULTS:
: 3.142
: 3.1

** 基本フォーマット
最も汎用な指示子は ~~A~ で、フォーマット引数を1つ消費して美的な(人が読める)形で出力する。
~~S~ は人間向きというより、 ~READ~ で読み戻せるような出力を試みる。
この2つは最大で4つの前置パラメータをとり、値の後ろにパディングを付加するかどうか制御できる。

それ以外によく使うのは、改行を出力する ~~%~ 指示子と、新しい行を出力する ~~&~ 指示子がある。 ~~%~ は常に改行するが、 ~~&~ は行頭でない時のみ改行する。

** 文字指示子・整数指示子・浮動小数点数指示子
値の型に応じた指示子がある。文字を出力するのは ~~C~ 指示子で、文字に対してしか機能しないことを除けば ~~A~ と同じ。
コロン修飾子をつけると、スペース、タブ、改行といった、本来は印字されない文字を名前で出力するようになる。
アットマーク修飾子をつけると、Lispの文字リテラルのシンタックスで出力する。

整数を出力するのは ~~D, ~~X, ~~O, ~~B, ~~R~ の5つ。それぞれ基数が異なる。
コロンをつけると、桁区切りのカンマが入る。アットマークを付けると、常に符号を印字するようになる。
1つめの前置パラメータで出力幅の最小値を指定し、2つめのパラメータでパディング文字を指定することができる。
3つめと4つめでは、カンマ区切りの振る舞いを変えられる。

浮動小数点数の値を整形する指示子は ~~F, ~~E, ~~G, ~~$~ の4種類ある。普通は ~~F~ を使えば良さそう。


** 英語の指示子
英語の指示子にはやたら器用なものが多い。
~~R~ は基数を指定せずに使うと、数値を英単語やローマ数字で印字する。
#+begin_src lisp
  (format nil "~r" 1234)
#+end_src

#+RESULTS:
: one thousand two hundred thirty-four

~~P~ は、対応する引数に応じて複数形の s や ies をつけてくれる。
~~(~ ~~)~ はペアで使われ、その間に置かれた制御文字列の出力はすべて小文字に変換される。アットマークを付けると文の頭が大文字になり、コロンをつけると全ての単語の頭文字が大文字になる。コロンとアットマークを両方つけると、文章が全て大文字になる。

** 条件による整形
FORMATには制御構文を実装する指示子が用意されている。

条件選択指示子 ~~[ ~~]~ は、この中に ~~;~ に区切られた節を複数置くことができ、制御文字列としてどれか一つが選ばれる。節の選択には数字のインデックスが使える
#+begin_src lisp :results output
  (format t "~[cero~;uno~;dos~]~%" 0)
  (format t "~[cero~;uno~;dos~]~%" 1)
  (format t "~[cero~;uno~;dos~]~%" 2)
#+end_src

#+RESULTS:
: cero
: uno
: dos

引数の値が節の個数より大きい場合は何も印字されない。ただし最後の節の区切りが ~~:;~ の場合は、最後の節がデフォルトの節として返される。
インデックスではなく、前置パラメータを使って節を決定することもできる。普通はあまり意味がないが、前置パラメータ ~~#~ を使うと以下のような芸当ができる。
#+begin_src lisp :results output
  (defparameter *list-etc*
    "~#[NONE~;~a~;~a and ~a~:;~a, ~a~]~#[~; and ~a~:;, ~a, etc~].~%")

  (format t *list-etc*)
  (format t *list-etc* 'a)
  (format t *list-etc* 'a 'b)
  (format t *list-etc* 'a 'b 'c)
  (format t *list-etc* 'a 'b 'c 'd)
#+end_src

#+RESULTS:
: NONE.
: A.
: A and B.
: A, B and C.
: A, B, C, etc.

コロンをつけると、 ~~[~ には2つの節しか含められなくなる。このときはフォーマット引数を1つ消費して、その引数が ~NIL~ の場合には最初の節を処理し、それ以外の場合には2つめの節を処理するようになる。caseじゃなくてifになるわけか。
アットマークをつけると ~~[~ には1つしか節を含められなくなる。指示子は引数を1つ消費し、それが ~NIL~ でなかったら、その引数をまた使えるように元の場所に戻してから、その節を処理する。

** 反復
反復指示子 ~~{~ はリストの要素や、リストに見立てたフォーマット引数を対象にして処理を繰り返す。修飾子がない場合はフォーマット引数としてリストを1つ消費し、要素がなくなるまで処理を繰り返す。
#+begin_src lisp
  (format nil "~{~a, ~}" (list 1 2 3))
#+end_src

#+RESULTS:
: 1, 2, 3,

最後についてしまうコンマとスペースを取り除くには、 ~~^~ 指示子を使う。
アットマーク修飾子をつけて使うと、 ~~{~ は残りのフォーマット引数をリストとして処理する。
#+begin_src lisp
  (format nil "~@{~a~^, ~}" 1 2 3)
#+end_src

#+RESULTS:
: 1, 2, 3

~~{~ と ~~}~ の中では、前置パラメータ ~#~ が参照する値の意味が変わり、「ループで処理されずに残っている要素の個数」になる。
#+begin_src lisp :results output
  (defparameter *english-list*
    "~{~#[~;~a~;~a and ~a~:;~@{~a~#[~;, and ~:;, ~]~}~]~}~%")

  (format t *english-list* '())
  (format t *english-list* '(1))
  (format t *english-list* '(1 2))
  (format t *english-list* '(1 2 3))
  (format t *english-list* '(1 2 3 4))
#+end_src

#+RESULTS:
: 
: 1
: 1 and 2
: 1, 2, and 3
: 1, 2, 3, and 4

** 引数の読み飛ばし
~~*~ を使うと、フォーマット引数の読み込み方を変更できる。修飾子をつけない形だと、次の引数を消費して、読み飛ばす。
よく使われるのはコロンをつけた形で、こうすると引数のリストを前に戻れるようになり、同じ引数が2回使えるようになる。
たとえば以下のようにすると、同じ引数を一回は英単語で、もう一回は数値で印字できる。
#+begin_src lisp
  (format nil "~r ~:*(~d)" 1)
#+end_src

#+RESULTS:
: one (1)

~~{~ 指示子の中では、 ~~*~ はリストにあるアイテムを飛ばしたり逆戻りしたりする。
#+begin_src lisp
  (format nil "~{~s~*~^ ~}" '(:a 10 :b 20))
#+end_src

#+RESULTS:
: :A :B

* 第19章 例外処理を越えて：コンディションと再起動
#+begin_quote
コンディションはプログラムの実行中に起こるすべての出来事を表現できるので、例外よりも汎用性が高い。
#+end_quote
#+begin_quote
Common Lispのエラー処理システムのやり方は、実際にエラーから回復するコードと、どうやって回復するかを決めるコードとを分離するというものだ。これにより、どうやって回復するかという戦略は高位の関数のコードに任せて、回復のためのコードを低位の関数に書けるようになる。
#+end_quote

例: Webサーバのログのようなテキスト形式のログファイルを読むアプリケーション
- ~log-entry~ ログのエントリを表すオブジェクト
- ~parse-log-entry~ 文字列を受け取り、log-entryを返す関数
- ~parse-log-file~ ログファイル全体を読み込み、ファイル内の全エントリを表すリストを返す関数


** コンディション
コンディションは、コンディションの一般的な性質を示すクラスのオブジェクトで、そのインスタンスには詳細情報が保持されている。

仮想的なログ解析プログラムのために、 ~parse-log-entry~ が「パースできないデータが与えられたこと」を通知する(OOP風に言うと、throwする)コンディションクラス ~malformed-log-entry-error~ を定義してみる。
コンディションクラスは ~DEFINE-CONDITION~ マクロで定義する。これは本質的には ~DEFCLASS~ と同じだが、デフォルトのスーパークラスが ~CONDITION~ になっている点や、スロットに ~SLOT-VALUE~ でアクセスできない点が異なる。 ~MAKE-CONDITION~ で新しいコンディションオブジェクトを作成する。

*エラー処理にコンディションを使う場合には、コンディションを ~CONDITION~ のサブクラスである ~ERROR~ のサブクラスとして定義すべきだ。*
parse-log-entryへの引数を保持するスロットを持ったコンディションを定義するには次のようにする。
#+begin_src lisp :eval no
  (define-condition malformed-log-entry-error (error)
    ((text :initarg :text :reader text)))
#+end_src

** コンディションハンドラ
parse-log-entry内でエントリをパースできなかった場合、malformed-log-entry-errorが通知される。エラーは関数 ~ERROR~ を使って通知する。 ~ERROR~ はさらに低位の関数 ~SIGNAL~ を呼び出し、コンディションが処理されない場合にはデバッグに落ちる。

~ERROR~ を呼ぶ方法は、コンディションオブジェクトを渡す方法と、コンディションクラスの名前と初期化引数を渡す方法の2種類ある。前者はコンディションオブジェクトを再利用するときに便利だが、一般に後者の方が簡潔になる。parse-log-entryは次のように書ける。
#+begin_src lisp :eval no
  (defun parse-log-entry (text)
    (if (well-formed-log-entry-p text)
        (make-instance 'log-entry ...)
        (error 'malformed-log-entry-error :text text)))
#+end_src

エラーが通知されたときに何が起こるかは、コールスタック上でparse-log-entryの上位に何があるかによる。デバッガの発動を避けるには、parse-log-entryを呼び出す関数のどれかでコンディションハンドラ(OOP風に言うと、try~catch)を確立しなければならない。通知機構はコンディションが通知されたとき、アクティブなコンディションハンドラのリストを調べ、そこからコンディションを処理できるハンドラをコンディションのクラスに基づいて探し出す。

各コンディションハンドラは、扱えるコンディションの型を示す型指定子と、コンディションを受ける1つの引数を取る関数とから構成されている。どの瞬間にも、コールスタックの様々なレベルで確立されたアクティブなコンディションハンドラがいくつも存在し得る。 *それらのうち通知機構が探し出すのは、通知されたコンディションと互換な型指定子を持つ、最も直近に確立されたハンドラだ。* 通知機構は、そのハンドラの関数にコンディションオブジェクトを渡して呼び出す。

呼び出されたハンドラの関数では、コンディションを処理するかどうかを選択できる。
コンディションを処理しない選択をした場合は、制御が ~SIGNAL~ 関数にもどり、互換性がある型指定子のうちで次に確立されたハンドラを探すことになる。
コンディションを処理する場合には、関数は制御を ~SIGNAL~ の外に移さなくてはいけない。たいてい、スタックを遡り、エラーの発生箇所で何らかのコードを実行することになる。

コンディションハンドラは ~HANDLER-CASE~ マクロで作成できる。
#+begin_src lisp :eval no
  (handler-case expression
    (condition-type ([var]) code)* )
#+end_src
expressionが何も起きず普通に戻った場合は、その戻り値が ~HANDLER-CASE~ から戻る。expressionがcondition-typeで指定されたコンディションを通知した場合には、適切なerror-clauseのコードが選択され、その実行結果が ~HANDLER-CASE~ の戻り値になる。varを指定すると、ハンドラのコードが実行されるときのコンディションオブジェクトを保持する変数の名前になる。

例えば、malformed-log-entry-errorがparse-log-entryによって、呼び出し元(parse-log-file)に通知されたとする。malformed-log-entry-errorを処理する方法としては、不正なエントリをスキップするという手がある。
#+begin_src lisp
  (defun parse-log-file (file)
    (with-open-file (in file :direction :input)
                    (loop for text = (read-line in nil nil) while text
                          for entry = (handler-case (parse-log-entry text)
                                                      (malformed-log-entry-error () nil))
                          when entry collect it)))
#+end_src

** 再起動
上記のparse-log-fileはエラー処理をやりすぎている。Common Lispのコンディションシステムではさらに、エラー処理のコードを2つの部分に分離する。コンディションハンドラをアプリケーションの上位に移し、再起動のコードをparse-log-fileやparse-log-entryといった中位や低位の関数におく。

~RESTART-CASE~ は ~HANDLER-CASE~ によく似ているが、再起動の名前はコンディション型の名前である必要はない。
#+begin_src lisp
  (defun parse-log-file (file)
    (with-open-file (in file :direction :input)
                    (loop for text = (read-line in nil nil) while text
                          for entry = (restart-case (parse-lot-entry text)
                                                    (skip-log-entry () nil))
                          when entry collect it)))
#+end_src
このparse-log-fileは直接はエラーを処理せず、最終的にはデバッガが起動する(restart)。ただしデバッガが用意した選択肢の中にskip-log-entryというのがあり、それを選択すれば、それまで通りparse-log-fileの処理が続けられる。デバッガを避けるには、skip-log-entryの再起動を自動的に呼び出すコンディションハンドラを確立すればいい。

parse-log-fileでエラーを直接処理せず、代わりに再起動を確立することで、parse-log-file関数がより汎用的になった。
高位のコードでは、エラーを処理するかどうかを選択できる。不正なログエントリを常にスキップするようにしたければ、高位の関数でskip-log-entry再起動を呼び出すコンディションハンドラを確立すればいい。
ただし、 ~HANDLER-CASE~ が出てくる関数のところまでスタックが巻き戻ってしまうので、ここで ~HANDLER-CASE~ を使うことはできない。代わりに、より低位のマクロ ~HANDLER-BIND~ を使う必要がある。
#+begin_src lisp :eval no
  (handler-bind (binding*) form*)
#+end_src
各bindingはコンディション型とハンドラ関数からなるリスト。ハンドラは関数オブジェクトでなければならず、引数を1つ取らなければならない。そして、 ~HANDLER-BIND~ でバインドされたハンドラ関数は、 *スタックを巻き戻らずに実行される。*
parse-log-entryでハンドラ関数が呼び出されたとすると、制御のフローは依然としてparse-log-entry呼び出しの内部にある。そのとき直近で束縛された再起動を呼び出すには ~INVOKE-RESTART~ を使う。

これらを使って次のようにすれば、parse-log-fileで確立された再起動skip-log-entryを呼び出すハンドラを、より上位のコードlog-analyzerに追加できる。
#+begin_src lisp
  (defun skip-log-entry (c)
    (invoke-restart 'skip-log-entry))

  (defun log-analyzer ()
    (handler-bind ((malformed-log-entry-error #'skip-log-entry))
      (dolist (log (find-all-logs))
        (analyze-log log))))
#+end_src
もしskip-log-entryが確立されずにmalformed-log-entry-errorが通知されると、 ~INVOKE-RESTART~ はskip-log-entry再起動を見つけられず、 ~CONTROL-ERROR~ を通知する。ある名前の再起動を見つけられなかった時に制御をより上位の関数に以上するには、 ~FIND-RESTART~ を使ってハンドラを以下のようにする
#+begin_src lisp
  (defun skip-log-entry (c)
    (let ((restart (find-restart 'skip-log-entry)))
      (when restart (invoke-restart restart))))
#+end_src

** 複数の再起動を提供する
より複雑な手順での復帰に対応できるように、再起動では任意の数の引数をとって ~INVOKE-RESTART~ の呼び出しに渡せるようになっている。
#+begin_src lisp
  (defun parse-log-entry (text)
    (if (well-formed-log-entry-p text)
        (make-instance 'log-entry ...)
      (restart-case (error 'malformed-log-entry-error :text text)
                    (use-value (value) value)
                    (reparse-entry (fixed-text) (parse-lot-entry fixed-text)))))
#+end_src
~USE-VALUE~ という名前は、「単純に与えられた値を戻り値として返す」ような再起動でよく使われる名前とのこと。

** コンディションの別の使い道
コンディションを通知しただけでは制御フローには何の影響もない。このことから、コンディションを別の目的で使うこともできる。

通知の基本的な関数は ~SIGNAL~ という。 ~SIGNAL~ は適用可能なコンディションハンドラを探索し、そのハンドラ関数を起動する。ハンドラの呼び出しは通常の関数呼び出しと何も変わらない。そのためハンドラは、制御の流れを変えずに普通の関数のように戻り、コンディションの処理を辞退することもできる。その場合は、次に適用可能なハンドラ（直近で次に束縛されたハンドラ）が ~SIGNAL~ によって呼び出される。仮に、適用可能なハンドラが見つからない、または適用可能なハンドラすべてが処理を辞退した場合は、そのコンディションは処理されないままで、 ~SIGNAL~ から ~NIL~ が返ってくる。

これまで使ってきた ~ERROR~ 関数は ~SIGNAL~ を呼び出す。そしてもし ~SIGNAL~ が返ってきたら、 ~ERROR~ はデバッガを起動する。したがって ~ERROR~ の呼び出しは普通に戻ることはない。コンディションは、コンディションハンドラで処理されるかデバッガの中で処理されなければならない。

このほかに、通知関数には ~WARN~ 関数もある。 ~WARN~ も ~ERROR~ と同じく ~SIGNAL~ を呼んでコンディションを通知するが、 ~SIGNAL~ が戻ってきてもデバッガを起動せず、コンディションを ~*ERROR-OUTPUT*~ に印字して ~NIL~ を戻す。その際 同時に、 ~MUFFLE-WARNING~ という名前の再起動も確立する。これをコンディションハンドラから呼び出せば、 ~WARN~ は何も印字せずに ~NIL~ を返す。

~SIGNAL~ を扱う3つめの方法として、 ~CERROR~ 関数がある。 ~CERROR~ は ~ERROR~ と同じように、通知したコンディションが処理されなければデバッガに落ちる。しかし ~WARN~ と同じように、コンディションを通知する前に再起動 ~CONTINUE~ を確立する。この再起動をコンディションハンドラから呼び出せばデバッガに落ちないようにできるほか、デバッガに落ちてしまった後でも、この再起動を使えば ~CERROR~ を呼び出した直後の計算から再開できる。

~SIGNAL~ を使って独自の手順を作成することもできる。 *低位のコードがコールスタックを遡って高位のコードと情報をやり取りする必要があれば、いつでもコンディションのメカニズムを使っていい。*

* 第20章 特殊オペレータ
特殊オペレータを使うと、言語の基礎となる機構へのアクセスが可能となる。

** 評価を制御する
このカテゴリには、 ~QUOTE~, ~IF~, ~PROGN~ の3つがある。
~QUOTE~ は評価をちゅうんだんする。 ~IF~ はブール選択の操作を提供する。 ~PROGN~ はいくつかの式を並べられるようにする。

** レキシカル環境を操作する
~LET~ と ~LET*~ は変数に対して新しいレキシカルな束縛を確立する。 ~SETQ~ はこれらで束縛された変数に値を設定するのに使える。

~FLET と ~LABELS~ を使ってローカル関数を定義できる。
#+begin_src lisp :eval no
  ;; function-difinition
  (name (parameter*) form*)

  (flet (function-definition*)
        body-form*)

  (labels (function-difinition*)
          body-form*)
#+end_src
~FLET~ で定義した関数の名前は ~FLET~ の本体でしか使えないが、 ~LABELS~ でつけた名前は ~LABELS~ で定義される関数の本体でも使える。
よって、 ~LABELS~ では再帰関数が定義できるが、 ~FLET~ ではできない。

ローカル関数は外側のスコープの変数を参照できるので、等価なヘルパー関数よりも引数の数を少なくできることが多い。これは関数パラメータとして1引数の関数を渡す必要がある時に便利。また、マクロでの生成対象としても便利。
~FLET~ や ~LABELS~ で定義された関数が表す関数オブジェクトを、 ~FUNCTION~ で取得することができる。それを ~LET~ で束縛することもできる。つまり、これらのローカル関数はクロージャとして使える。

~FLET~ と ~LABELS~ に近いものとして、ローカルマクロを定義する ~MACROLET~ がある。マクロの生成対象として便利なほか、コードの内側だけで使える構文要素を提供したり、グローバルなマクロを隠したりすることができる。

最後に、 ~SYMBOL-MACROLET~ を使うと見た目がシンボルのマクロを作れる。シンボルマクロは引数を取れず、リストのフォームではなく単純なシンボルとして参照される。ある名前でシンボルマクロを定義した後は、そのシンボルを値がくる場所で使うと展開されて、評価された結果がその場所に置かれる。C言語の #define に近いかな？

** ローカルなフローの制御
Common Lispの制御フローを支える下位のマクロとして、 ~BLOCK~, ~RETURN-FROM~, ~TAGBODY~, ~GO~ という4つの特殊オペレータがある。
~BLOCK~ と ~RETURN-FROM~ はあるコードのセクションからリターンするコードを書くために組み合わせて使う。 ~TAGBODY~ と ~GO~ も組み合わせて使い、高レベルなループ構文を支える、低レベルな goto構文を提供する。

~BLOCK~ の基本的なフォームは以下の通り。nameはシンボルで、formはLispのフォーム。
#+begin_src lisp :eval no
  (block name
         form*)
#+end_src
~BLOCK~ でhformが順番に評価されていく。途中で ~RETURN-FROM~ が使われてブロックから脱出してしまわない限り、最後のformが ~BLOCK~ 値として返される。 ~RETURN-FROM~ フォームは脱出するブロックの名前から構成され、オプションとして戻り値のフォームを提供する。 ~RETURN-FROM~ が評価されると、名前付き ~BLOCK~ から呼び出し元に、直ちに制御が戻る。  ~RETURN-FROM~ が戻り値のフォームと一緒に呼び出された場合には、その結果が ~BLOCK~ 全体の値となる。それ以外の場合、 ~BLOCK~ の評価結果は ~NIL~ になる。

~BLOCK~ の名前は、 ~NIL~ を含めてどのようなシンボルでもいい。例えば ~DO~, ~DOTIMES~, ~DOLIST~ といった制御構文マクロの多くは、その展開系に ~NIL~ という名前の ~BLOCK~ を含んでいる。このおかげで、これらのループを抜けるのに ~RETURN-FROM nil~ の構文糖衣である ~RETURN~ マクロが使えている。
#+begin_src lisp :results output
  (dotimes (i 10)
    (let ((answer (random 100)))
      (print answer)
      (if (> answer 50) (return))))
#+end_src

#+RESULTS:
: 
: 37 
: 68 

関数を定義する ~DEFUN~ マクロや ~FLET~, ~LABELS~ は、本体が関数と同じ名前の ~BLOCK~ オペレータで包まれている。このため、関数からの脱出に ~RETURN-FROM~ オペレータが使える。

~TAGBODY~ と ~GO~ の関係は ~BLOCK~ と ~RETURN-FROM~ の関係に似ていて、 ~TAGBODY~ で定義したコンテクストの名前を ~GO~ が利用する。
#+begin_src lisp :eval no
  (tagbody
     tag-or-compound-form*)
#+end_src
tag-or-compound-formには、タグと呼ばれるシンボルか、空でないリストのフォームを置く。リストのフォームは順番に評価され、タグは無視される。 ~TAGBODY~ のレキシカルスコープ内であれば、どこでも特殊オペレータ ~GO~ が使えて、どのタグへもすぐにジャンプできる。そして、そのタグに続けて評価が再開される。
#+begin_src lisp
  ;; 無限ループ
  (tagbody
     top
       (print 'hello)
       (go top))

  ;; タグは複数あってもいい
  (tagbody
     a (print 'a) (if (zerop (random 2)) (go c))
     b (print 'b) (if (zerop (random 2)) (go a))
     c (print 'c) (if (zerop (random 2)) (go b)))
#+end_src

** スタックの巻き戻し
コールスタックの振る舞いは、 ~BLOCK~ と ~TAGBODY~ によって実現されている。これらの特殊オペレータは普通は1つの関数における制御フローを扱うが、クロージャと組み合わせれば、非局所的な脱出に使うこともできる。

ブロックの名前はレキシカルなスコープを持つ。そのため、 ~RETURN-FROM~ が戻るのは、常にレキシカル環境の一番内側の ~BLOCK~ からになる。 ~RETURN-FROM~ が異なる動的なコンテキストから実行されたとしても、この ~BLOCK~ からリターンする。言い換えると、ブロックの外側のコードがブロックの内側からリターンしたければ、 ~BLOCK~ のレキシカルスコープ内にある ~RETURN-FROM~ を含むクロージャを起動するしかない。
~TAGBODY~ と ~GO~ も、この点では同じように動く。 ~GO~ を含むクロージャを起動したときに ~GO~ が評価されると、スタックが適切な ~TAGBODY~ まで巻き戻され、指定されたタグにジャンプする。

ただし、 ~BLOCK~ や ~TAGBODY~ はレキシカル変数の束縛とは異なり、これらがコールスタックに積まれている間だけ利用可能なことに注意。これを、 ~BLOCK~ や ~TAGBODY~ は動的エクステントを持つ、などという。

スタックの制御にかかわる特殊オペレータには最後にもう一つ、 ~UNWIND-PROTECT~ がある。これを使うと、スタックを巻き戻す時に起こることを制御できる。 ~UNWIND-PROTECT~ のスコープからどうやって制御が抜けるかにかかわらず、スコープから抜けた際に常に特定のコードが実行されることを保証することができる。つまり finally 節みたいなもの。
#+begin_src lisp :eval no
  (unwind-protect protected-form
    cleanup-form*)
#+end_src
あまり ~UNWIND-PROTECT~ を直接使うことはなく、WITH-系のマクロのベースとして使う。

** 多値
多値を返すことは、リストを返すのとはまったく違う。フォームから多値を返したら、その多値を捕える特別な操作をしない限り、1つめの値以外は捨てられてしまう。

多値を返すには、関数 ~VALUES~ と ~VALUES-LIST~ を使う。 ~VALUES~ は可変個の引数を取り、それらを多値として返す。 ~VALUES-LIST~ はリストを1つとり、その要素を多値として返す。関数でこれらの関数を使うと、その関数は多値を返すようになる。しかし、フォームが評価される時には先頭の値だけ使われる。

フォームによって返された多値を扱うには、特殊オペレータ ~MULTIPLE-VALUE-CALL~ が必要になる。これは ~FUNCALL~ に似ているが、関数に多値を渡すことができる点が異なる。
多値を変数に格納したいときは、 ~MULTIPLE-VALUE-BIND~ マクロを使う。
#+begin_src lisp :eval no
  (multiple-value-bind (variable*) values-form
    body-form*)
#+end_src
values-form が評価され、返された多値が variables に束縛される。そしてその束縛が有効な状態で body-forms が評価される。
#+begin_src lisp
  (multiple-value-bind (x y) (values 1 2)
    (+ x y))
#+end_src

#+RESULTS:
: 3

もう一つのマクロ ~MULTIPLE-VALUE-LIST~ はより単純で、フォームを1つとり、それを評価した結果の多値をリストにして返す。つまり ~VALUES-LIST~ の反対。
#+begin_src lisp
  (multiple-value-list (values 1 2))
#+end_src

#+RESULTS:
| 1 | 2 |

最後に、~VALUES~ は ~SETF可能~ なので、フォームによって戻される多値を既存の変数に代入することができる。
#+begin_src lisp :results output
  (defparameter *x* nil)
  (defparameter *y* nil)
  (dbg (setf (values *x* *y*) (floor (/ 57 34))))
  (dbg *x*)
  (dbg *y*)
#+end_src

#+RESULTS:
: (SETF (VALUES *X* *Y*) (FLOOR (/ 57 34))) => 1
: *X* => 1
: *Y* => 23/34

** EVAL-WHEN
~EVAL-WHEN~ は複雑な特殊オペレータだが、ある種のマクロを書くためには必要らしい。 ~EVAL-WHEN~ を理解するための必要条件は、 ~LOAD~ と ~COMPILE-FILE~ という2つの関数のやりとりを理解することだけ、とのこと。

~LOAD~ の仕事は、ファイルをロードしてすべてのファイルに含まれる全てのトップレベルフォームを評価すること。 ~COMPILE-FILE~ の仕事は、ソースファイルをFASLファイルにコンパイルすること。コンパイルされたFASLファイルは、Lispファイルと同じようにロードできる。
~LOAD~ では、先に評価するフォームの副作用が後のフォームの読み込みと評価の方法に影響しうる。一方の ~COMPILE-FILE~ は、通常はコンパイルするフォームを評価せず、FASLが読み込まれる時にそのフォームが評価される。ただし ~LOAD~ との生合成を取るために、 ~IN-PACKAGE~ や ~DEFMACRO~ といったフォームは評価する。

では、 ~IN-PACKAGE~ や ~DEFMACRO~ のようなフォームを、どのようにして先に評価するのか？
Common Lispではこれらを ~EVAL-WHEN~ を使って評価する。このオペレータを使うと、コードの特定の部分がいつ評価されるかを制御できるようになる。
#+begin_src lisp :eval no
  (eval-when (situation*)
    body-form*)
#+end_src
situationには ~:compile-toplevel~, ~:load-toplevel~, ~:execute~ の3種類があり、指定された状況に応じてbody-formが評価される。

まず、トップレベルフォームには以下のものがある
- トップレベルに直接現れるフォーム
- トップレベルにある ~PROGN~ に現れるフォーム
- ~MACROLET~ や ~SYMBOL-MACROLET~ に現れるフォーム
- トップレベルのマクロフォームの展開形

~EVAL-WHEN~ がトップレベルフォームの場合、 ~:compile-toplevel~ を指定すると、ファイルコンパイラは部分フォームをコンパイル時に評価するようになる。 ~:load-toplevel~ を指定すると、部分フォームはトップレベルフォームとしてコンパイルされる。いずれも指定しないと、トップレベルの ~EVAL-WHEN~ はコンパイラに無視される。

~EVAL-WHEN~ が非トップレベルフォームとしてコンパイルされる場合、 ~:execute~ が指定されていれば ~PROGN~ のようにコンパイルされ、指定がなければ無視される。 ~LOAD~ によって処理されたソースファイルのトップレベルにある ~EVAL-WHEN~ や、 ~:compile-toplevel~ が指定されたトップレベルの ~EVAL-WHEN~ の部分フォームにある ~EVAL-WHEN~ も、 ~:execute~ が指定されていれば ~PROGN~ のように処理され、指定がなければ無視される。

~EVAL-WHEN~ を使う主な場面は2つある。
- コンパイル時の情報を保存しておいて、同じファイル中の他のマクロフォームの展開に利用する場合
- マクロの定義とヘルパー関数の定義を、そのマクロを利用するコードと同じファイルに置きたい場合。 ~DEFMACRO~ はコンパイル時に読み込まれるが ~DEFUN~ はそうではない。マクロでヘルパー関数を使っている場合は、その関数を ~:compile-toplevel~ 付きの ~EVAL-WHEN~ で包むことで、マクロに関する全ての定義をコンパイル時に読み込むことができる。
* 第21章 大規模開発に向けて：パッケージとシンボル
Common Lispの読み取り機はどのようにして、名前を形作る文字列をシンボルに変換するのだろうか？ 名前衝突を避けるには？

** パッケージ
パッケージとは文字列とシンボルを対応づける表だと考えることができる。パッケージには名前があり、その名前と ~FIND-PACKAGE~ 関数でパッケージを探すことができる。

読取器は、あるパッケージの対応表に、 ~FIND-SYMBOL~ と ~INTERN~ の2つの関数を使ってアクセスする。両方とも文字列を引数にとり、オプションでパッケージを指定できる。引数としてパッケージを渡さないと、デフォルト値である ~*PACKAGE*~ の値が使われる。 ~*PACKAGE*~ はカレントパッケージと呼ばれる。
~FIND-SYMBOL~ は与えられた文字列を名前に持つシンボルをパッケージの中から探し、そのシンボルを返す。シンボルが見つからない場合は ~NIL~ を返す。 ~INTERN~ もほぼ同じ振る舞いをするが、シンボルが見つからない時には代わりに、新しくシンボルを作ってパッケージに追加する。

コロンを1つだけ含む名前は、外部パッケージの公開シンボルを参照できる。コロンを2つ連続して含む名前は、外部パッケージの全てのシンボルを参照できるが、プライベートなインタフェースにアクセスしているということなので、推奨されない。
コロンではじまる名前は特殊で、これはキーワードシンボルになる。キーワードシンボルは ~KEYWARD~ パッケージにインターンされ、自動的にエクスポートされる。
~#:~ ではじまる名前も特殊で、これはアンインターンドシンボルと呼ばれ、どのパッケージにも属さない。 ~GENSYM~ 関数で見かける。


** 標準パッケージ
Common Lispには標準パッケージが3つある。COMMON-LISP-USER, COMMON-LISP, そしてKEYWORD パッケージだ。

最初にLispを起動した時の ~*PACKAGE*~ の値は、 COMMON-LISP-USER になる。CL-USER という省略形の場合もある。
#+begin_src lisp
 *package*
#+end_src

#+RESULTS:
: #<PACKAGE "COMMON-LISP-USER">

COMMON-LISP-USERでは、Common Lisp の標準で定義されている全てのシンボルをエクスポートしている COMMON-LISP パッケージを利用できる。もし ~REPL~ で言語標準の名前を使うと、それらは COMMON-LISP パッケージからエクスポートされたシンボルへと変換される。それ以外の名前は、COMMON-LISP-USER パッケージにインターンされる。
#+begin_src lisp :results output
  ;; パッケージ名
  (dbg common-lisp:*package*)
  (dbg cl:*package*)

  ;; どのパッケージのシンボルを継承しているか確認する
  (dbg (mapcar #'package-name (package-use-list :cl-user)))
  (dbg (mapcar #'package-name (package-use-list :common-lisp)))

  ;; 特定のシンボル('car)がどのパッケージに由来するものなのか調べる
  (dbg (package-name (symbol-package 'car)))
#+end_src

#+RESULTS:
: *PACKAGE* => #<PACKAGE "COMMON-LISP-USER">
: *PACKAGE* => #<PACKAGE "COMMON-LISP-USER">
: (MAPCAR #'PACKAGE-NAME (PACKAGE-USE-LIST :CL-USER)) => ("COMMON-LISP"
:                                                         "SB-ALIEN" "SB-DEBUG"
:                                                         "SB-EXT" "SB-GRAY"
:                                                         "SB-PROFILE")
: (MAPCAR #'PACKAGE-NAME (PACKAGE-USE-LIST :COMMON-LISP)) => NIL
: (PACKAGE-NAME (SYMBOL-PACKAGE 'CAR)) => "COMMON-LISP"

3つめに、読取器が転んではじまる名前をインターンする際に使う ~KEYWORD~ パッケージが標準で使える。
#+begin_src lisp :results output
  (dbg :a)
  (dbg keyword:a)
  (dbg (eql :a keyword:a))
#+end_src

#+RESULTS:
: :A => :A
: :A => :A
: (EQL :A :A) => T

** 自分でパッケージを定義する
パッケージでは、誰がどの関数を呼べてどの変数にアクセスできるかを直接制御することはできない。その代わり、どうやって名前をシンボルオブジェクトへと変換するかを制御することができる。したがって関数や変数をパッケージからエクスポートするというのは意味がない(HaskellやErlangのパッケージとはこの点が異なる)。

パッケージがエクスポートできるのはシンボルだけ。名前がどうやって使われるかを、パッケージシステムで制限できるわけではない。
言い換えると、パッケージでは名前空間を提供するが、アクセス制御は提供されていない。

パッケージを定義するには ~DEFPACKAGE~ マクロを使う。このマクロによってパッケージを作れるだけでなく、インポートやエクスポート、名前衝突の解消ができる。
もし作ろうとしているアプリケーションが標準ライブラリ以外使わないシンプルなものであると仮定すると、以下のようにしてパッケージを定義できる。
#+begin_src lisp
  (defpackage :jp.ac.dendai.im.cps.yoshiki.app1
    (:use :common-lisp))
#+end_src

#+RESULTS:
: #<PACKAGE "JP.AC.DENDAI.IM.CPS.YOSHIKI.APP1">

このパッケージ内のコードを読み込むためには、 ~IN-PACKAGE~ マクロを使ってパッケージをLispのカレントパッケージにする必要がある。
~IN-PACKAGE~ を実行すると ~*PACKAGE*~ の値が変わり、後続の式に影響する。この影響は再度 ~IN-PACKAGE~ を呼び出して変更するまで続く。
#+begin_src lisp :results output
  (in-package :jp.ac.dendai.im.cps.yoshiki.app1)
  (dbg *package*)
  (defun hello-world () (format t "hello from app1~%"))
  (hello-world)
  (in-package :cl-user)
  (defun hello-world () (format t "hello from cl-user~%"))
  (dbg *package*)
  (hello-world)
#+end_src

#+RESULTS:
: *PACKAGE* => #<PACKAGE "JP.AC.DENDAI.IM.CPS.YOSHIKI.APP1">
: hello from app1
: *PACKAGE* => #<PACKAGE "COMMON-LISP-USER">
: hello from cl-user

** シンボルのエクスポート・インポート
作成したパッケージからシンボルをエクスポートするには、 ~:export~ を使って以下のようにする。
#+begin_src lisp
  (defpackage :jp.ac.dendai.im.cps.yoshiki.lib1
    (:use :common-lisp)
    (:export :open-db
             :save
             :store))
#+end_src

#+RESULTS:
: #<PACKAGE "JP.AC.DENDAI.IM.CPS.YOSHIKI.LIB1">

作成したパッケージからエクスポートしたシンボルを、別のパッケージでインポートするには ~:use~ を使って以下のようにする。
#+begin_src lisp
  (defpackage :jp.ac.dendai.im.cps.yoshiki.app2
    (:use :common-lisp :jp.ac.dendai.im.cps.yoshiki.lib1))
#+end_src

#+RESULTS:
: #<PACKAGE "JP.AC.DENDAI.IM.CPS.YOSHIKI.APP2">

サードパーティのライブラリをインポートしたい場合も上記と同じように ~:use~ を使えるが、 ~:import-from~ を使って一部のシンボルだけをインポートするやり方もある。Pythonの import...from~~~ みたいな。
#+begin_src lisp :eval no
  (defpackage :jp.ac.dendai.im.cps.yoshiki.app3
    (:use :common-lisp)
    (:import-from :com.some.lib1 :com.some.lib2))
#+end_src
逆に、一部のシンボルだけ「インポートしたくない」こともあるかもしれない。例えば、同じ名前をエクスポートする2つのパッケージを使いたいというケースでは、衝突している名前を未修飾でインポートするわけにはいかない。そんな時は ~:shadow~ を使うことでシンボルのインポートを阻止し、名前の曖昧さを回避できる。
#+begin_src lisp :eval no
  (defpackage :jp.ac.dendai.im.cps.yoshiki.app3
      (:use :common-lisp)
      (:import-from :com.some.lib1 :com.some.lib2)
      (:shadow :some-func :some-macro))
#+end_src
~:shadowing-import-from~ を使えば、曖昧さを解決して、衝突している名前をどちらのパッケージからのシンボルと見なすか決定できる。
#+begin_src lisp :eval no
  (defpackage :jp.ac.dendai.im.cps.yoshiki.app3
      (:use :common-lisp)
      (:import-from :com.some.lib1 :com.some.lib2)
      (:shadow :some-func :some-macro) ; lib1, lib2 にある some-func, some-macro の名前は取り込まれない。ないものとされる
      (:shadowing-import-from :com.some.lib1 :other-func) ; other-func は 名前が衝突しているけど、lib1由来のものということにする
      (:shadowing-import-from :com.some.lib2 :other-macro)) ; other-macroはlib2由来ということにする
#+end_src

** パッケージ化の定石
1. ~DEFPACKAGE~ をすべて集めて、別のファイルに置く。packages.lisp など
2. 他のファイルをコンパイルしたりロードしたりする前に packages.lisp がロードされるようにする。

実際には、ASDF や roswell を使うと簡単なんでしょうね。

cc-ppcre は上記のやり方っぽかった。https://github.com/edicl/cl-ppcre
深町さんはファイルごとに cl-user 環境で ~DEFPACKAGE~ してから、そのパッケージに ~IN-PACKAGE~ しているみたいだった。いずれこっちを真似しようと思う。 https://github.com/fukamachi/woo

* 第22章 黒帯のためのLOOP
LOOPでできること
- 数値や変数を更新する
- ループしている間に作られる値を収集(collect)、集計(count)、合計(sum)、最小化(minimize)、最大化(maximize)する
- 任意の Lisp 式を実行する
- いつループを終了するか決める
- 上記を条件付きで実行する

~LOOP~ は節の集合で、各節はループキーワードで始める。主要なキーワードには、 for, collect, sum, count, do, finally などがある。

** 反復
*** 基本形

ループキーワード ~for~ で反復を制御できる。 ~as~ というエイリアスも用意されている。forの後には変数の名前が続く。
#+begin_src lisp :eval no
  (loop
   for item in list
   for i from 1 to 10
   do (something))
#+end_src

~for~ はC言語のような形式を提供する。ループの開始・終了・ステップ のそれぞれで、追加で以下のようなキーワードがある。
開始位置 ... from, downfrom, upfrom
終了位置 ... to, upto, below, downto, above、
ステップ ... by

上記のキーワードを少なくとも1つ指定しなければならない。デフォルトでは0から始まり、ステップ数は+1で、永久にループする。
#+begin_src lisp :results output
  (dbg (loop for i upto 10 collect i))
  (terpri)
  (dbg (loop for i from 0 downto -10 collect i))
#+end_src

#+RESULTS:
: (LOOP FOR I UPTO 10
:       COLLECT I) => (0 1 2 3 4 5 6 7 8 9 10)
: 
: (LOOP FOR I FROM 0 DOWNTO -10
:       COLLECT I) => (0 -1 -2 -3 -4 -5 -6 -7 -8 -9 -10)

C言語のような形式ではなく、単に指定回数ループしたい(whileのような)場合には、代わりに ~repeat~ キーワードを使う。
#+begin_src lisp :results output
  (loop repeat 3 do (format t "hello~%"))
#+end_src

#+RESULTS:
: hello
: hello
: hello

*** リストの反復 
リストの要素をループしたい場合は、 ~in~ を使う。リストをなめる時に使う関数を ~by~ で指定できる。通常は順々に見ていくので ~cdr~ がデフォルトになっている。
#+begin_src lisp
  (loop for i in (list 10 20 30 40) collect i) ;by節は暗黙に'cdrになり、全ての要素を見ていく
#+end_src

#+RESULTS:
| 10 | 20 | 30 | 40 |

#+begin_src lisp
  (loop for i in (list 10 20 30 40) by #'cddr collect i) ;10を見た後、cddrを使って30を見るので、この2つしか列挙されない
#+end_src

#+RESULTS:
| 10 | 30 |

リストをループする際に、要素ではなくコンスセル全体を扱うには、 ~on~ を使う。 ~by~ も使える。
#+begin_src lisp
  (loop for i on (list 10 20 30 40) by #'cdr collect i) ;要素を順々に見ながら、末尾までのコンスセル全体をcollectしていく
#+end_src

#+RESULTS:
| 10 | 20 | 30 | 40 |
| 20 | 30 | 40 |    |
| 30 | 40 |    |    |
| 40 |    |    |    |

*** ベクタの反復 
文字列やビットベクタを含むベクタの要素をループしたい場合は、 ~in~ の代わりに ~across~ を使う。別のキーワードを使わなければいけない理由は、loopがマクロであるため、対象のデータ型をコンパイル時に把握しなければならないから。前置詞が何かを見て、データ型を判断している。
#+begin_src lisp
  (loop for x across "abcd" collect x)
#+end_src

#+RESULTS:
: (#\a #\b #\c #\d)

*** ハッシュテーブルやパッケージのシンボルに対する反復
ハッシュテーブルの反復とパッケージの反復は両方とも同じパターンに従い、以下のようになる。
#+begin_src lisp :eval no
  (loop for <var> being the <things> in <hash-or-package> ...)
#+end_src

ハッシュテーブルの場合、<things> の値には hash-keys か hash-values がくる。そして <var> が、ハッシュテーブルのキーまたは値のいずれかに次々と束縛される。 <hash-or-package> フォームはハッシュの値を生成するために一度だけ評価される。

パッケージの場合は <things> が symbols か present-symbols か external-symbols になる。これにより <var> は、そのパッケージでアクセス可能な各シンボルか、そのパッケージに存在しているシンボル（つまりパッケージにインターンされたものとインポートされたもの）か、そのパッケージからエクスポートされたシンボルのいずれかに束縛される。<hash-or-package> には ~FIND-PACKAGE~ と同じように、パッケージオブジェクトを渡すことができる。

キーワードのエイリアスとして、the の代わりに each を、inの代わりに of が使える。また、ハッシュテーブルをループする際にキーとバリューを両方取り出せる using キーワードが用意されている。
#+begin_src lisp :eval no
  (loop for k being the hash-keys in h using (hash-value v) ...)
  (loop for v being the hash-values in h using (hash-key k) ...)
#+end_src

** = と then による反復
上記の基本形やリストの反復などでは上手くループを表現できない場合は、 ~=~ と ~then~ を使った代入節を使うことで、ループ内の変数を完全に制御することができる
#+begin_src lisp :eval no
  (loop for <var> = <intial-value-form> [ then <step-form> ] ...)
#+end_src
#+begin_src lisp
  (loop repeat 5
        for x = 0 then y
        for y = 1 then (+ x y)
        collect y)
#+end_src

#+RESULTS:
| 1 | 2 | 4 | 8 | 16 |

#+begin_quote deepseek-r1:free
このコードは最初の5つのフィボナッチ数を生成するループです。次のように動作します：

1. `repeat 5`：5回繰り返し
2. 変数の初期化：
   - `x` は0で初期化され、次回から前回の`y`の値を受け取る
   - `y` は1で初期化され、次回から`x + y`の値になる
3. 各イテレーションで`y`を収集

実行ステップ：
1. 1回目: x=0 → y=1 → (1)
2. 2回目: x=1 → y=0+1=1 → (1 1)
3. 3回目: x=1 → y=1+1=2 → (1 1 2)
4. 4回目: x=2 → y=1+2=3 → (1 1 2 3)
5. 5回目: x=3 → y=2+3=5 → (1 1 2 3 5)

結果：`(1 1 2 3 5)`  
（xとyは並行更新されるため、古典的なフィボナッチ数列生成ロジックとして機能します）
#+end_quote

** loopでの変数
ループで補助的な変数が必要なときは、 ~with~ 節を使って変数を宣言できる。
#+begin_src lisp :eval no
  with <var> [ = <init-value-form> ]
#+end_src

ループ変数に代入されたリストの値は、パターンマッチのように書くと分配できる。
#+begin_src lisp :results output
  (loop for (a b) in '((1 2) (3 4) (5 6))
        do (format t "a: ~a; b: ~a~%" a b))
#+end_src

#+RESULTS:
: a: 1; b: 2
: a: 3; b: 4
: a: 5; b: 6

パターンマッチのような部分はドット対を含むことができ、その場合ドットの後の名前は &rest パラメータのように作用して、リストの残りの要素を全て含んだリストに束縛される。
#+begin_src lisp :results output
  (loop for (item . rest) on (list 1 2 3 4)
        do (format t "~a" item)
        when rest do (format t ", "))
#+end_src

#+RESULTS:
: 1, 2, 3, 4

パターンマッチのようなことをした後の値を無視したければ、 ~NIL~ にする。
#+begin_src lisp
  (loop for (a nil) in '((1 2) (3 4) (5 6)) collect a)
#+end_src

#+RESULTS:
| 1 | 3 | 5 |

** 値の累積
ループでは値を累積するような操作が簡潔に書ける。累積節は以下のパターンに従う。
#+begin_src lisp :eval no
  <verb> <form> [ into <var> ]
#+end_src
累積節はループのたびに <form> を評価し、その値を <verb> によって決められた方法で累積していく。オプションで ~into~ 副節を使うと、値は <var> で名付けられた変数に保存される。その変数はループだけのローカルなもので、 ~with~ 節で宣言されたように扱われる。

<verb>には ~collect, append, nconc, count, sum, maximize, minimize~ がある。それぞれの現在分詞(collectingなど)も同じ意味で使える。

~collect~ は、フォームの値を出てきた順に並べてリストを作る。 ~append~ と ~nconc~ はフォームの結果であるリストを、値としてリストに累積し、 ~APPEND~ や ~NCONC~ 関数のようにして1つのリストにする。

残りの動詞は数値を累積するのに使われる。 ~count~ は <form> が真になる回数を数え、 ~sum~ は <form> 全体の合計を出す。 ~maximize~ は <form> の最大の値を集め、 ~minimize~ は <form> の最小を集める。
#+begin_src lisp
  (defparameter *random* (loop repeat 100 collect (random 10000)))

  (loop for i in *random*
        counting (evenp i) into evens
        counting (oddp i) into odds
        summing i into total
        maximizing i into max
        minimizing i into min
        finally (return (list min max total evens odds)))
#+end_src

#+RESULTS:
| 5 | 9987 | 481926 | 50 | 50 |

** loopでLisp式を実行する

*** 無条件実行
ループの本体で任意のコードを実行するには ~do~ 節を使う。do節は do または doing という単語と、それに続く1つ以上のLispフォームから構成されている。そしてdo節が評価される時に、それらのLispフォームが全て評価される。do節はループの閉じかっこか、次のループキーワードの箇所で終わる。
#+begin_src lisp :results output
  (loop for i from 1 to 10 do (print i))
#+end_src

#+RESULTS:
#+begin_example

1 
2 
3 
4 
5 
6 
7 
8 
9 
10 
#+end_example

~return~ 節も無条件に実行される。この節は return という語とそれに続く1つのLispフォームから構成され、フォームを評価した結果がループの値として返される。 ~return~ 節は単にLOOPから脱出するだけ。 ~RETURN~ や ~RETURN-FROM~ はさらに外側のブロックから脱出できる。

*** 条件実行
条件構文は ~if, when, unless~ の3種類ある。条件構文は以下のパターンに従う。
#+begin_src loop :eval no
  ([if when unless] <test-form> <loop-clause>)
#+end_src
<test-form> にはLispフォームをなんでも使うことができる。 <loop-clause> には累積節や無条件実行節、その他の条件実行節が使える。 ~and~ でさらに条件節を続けることもできる。

さらに構文糖衣として、 <test-form> によって返された値を参照する変数 ~it~ を使うことができる。例えば以下のループでは、 some-list 内のキーで some-hash をルックアップし、出てきた値を ~it~ を使って collect することができる。
#+begin_src lisp
  (loop for key in some-list when (gethash key some-hash) collect it)
#+end_src

これら3種の条件実行節は、 ~else~ で分岐させることもできる。
また、条件実行節を入れ子にした場合、入れ子構造を明確にするために節を終了する単語 ~end~ が使える。

** セットアップと後始末
ループの実行の前に何かしら初期化をし、ループの後でループ計算した値を使用したい。このために LOOP には ~initially~ および ~finally~ という2つのキーワードが用意されている。これらを使うと、ループの外で動くコードをループに導入できる。

~initially~ に続くフォームは単一の *前処理部* にまとめられ、ループ内のローカル変数の初期化とループ本体部の実行の間のフェーズで、一度だけ実行される。 ~finally~ に続くフォームも同様に1つの *後処理部* にまとめられ、ループ本体の最後の反復が終わった後に実行される。
前処理部と後処理部では、ループ内のローカルな変数を参照できる。

前処理部は、必ず実行される。後処理部については、以下のいずれかの場合には実行せずにループから戻ることができる。
- ~return~ 節が実行される時
- ~RETURN~ や ~RETURN-FROM~ のような制御を移行する構文要素が LOOP のなかで呼ばれた時
- ~always, never, theris~ 節でループが終了する時

後処理部のコードでは、ループの戻り値を指定するのに、 ~RETURN~ や ~RETURN-FROM~ を使うことができる。このような戻り値は、累積節や終了条件節によって作られる戻り値よりも優先される。

入れ子になったLOOPから抜けるには、 ~RETURN-FROM~ を使う。 ~named~ キーワードを使うとLOOPに名前をつけることができ、この名前を指定して使う。 ~named~ 節は、ループ内の最初の節に書く必要がある。
例えばリストのリストであるlistsから、ある条件にマッチした要素を探すとする。以下のようにすると、 ~RETURN-FROM~ でループを一気に抜けることができる。
#+begin_src lisp :eval no
  (loop named outer for list in lists do
        (loop for item in list do
              (if (what-i-am-looking-for-p item)
                  (return-from outer item))))
#+end_src

** 終了条件のテスト・ループの戻り値
終了条件節は反復からリターンするタイミングを決める節で、 ~while, until, always, never, thereis~ がある。これらは以下のパターンに従う。
#+begin_src lisp :eval no
  <loop-keyword> <test-form>
#+end_src
<test-form> を反復のたびに評価し、結果の値に応じてループを終了するかどうかを決定する点は5つとも同じだが、終了を決定する方法と、終了させた時の挙動がそれぞれ異なる。

ループキーワード ~while~ と ~until~ は「マイルドな」終了節を提供する。これらがループの終了を決定した場合、ループの本体の残りを飛ばして、制御は後処理部(finally)に移る。
~while~ は <test-form> が最初に失敗した場合にループを終了させる。 ~until~ は <test-form> が最初に真になった時にループを終了させる。
~LOOP-FINISH~ マクロによっても、後処理部に制御を移す動きができる。これはループ節ではなく普通のLisp式なので、loop内のdo節の中ならどこで使ってもいい。

残りの3つの ~always, never, thereis~ は有無を言わさずループを終了する。ループからすぐに戻り、後続のループ節のみならず後処理部もすっ飛ばしてしまう。これらの終了条件節によってループを脱出した場合、ループの値はあらかじめ設定したデフォルト値になる。またこのことから、これらの終了条件節は ~into~ 副節を持たない累積節と組み合わせるとコンパイルエラーになる。戻り値を終了節由来のものにすればいいのか、累積節由来のものにすればいいのか決定できないからだ。

~always~ 節と ~never~ 節はブール値だけ返すので、ループ式を述語の一部として使う場合に便利だ。 ~always~ は毎回の反復で <test-form> が真であることをチェックするのに使える。反対に ~never~ は、毎回の反復で <test-form> が ~NIL~ に評価されることをテストする。 <test-form> が失敗した場合、そのループはすぐに終了して ~NIL~ を返す。ループが完了した場合にはデフォルトである ~T~ が提供される。
例えば、リスト内のすべての数値 numbers が偶数であるかどうかをテストしたければ以下のように書くことができる。
#+begin_src lisp :results output
  (defparameter *numbers* (list 2 4 6 8))

  (if (loop for n in *numbers* always (evenp n))
      (print "All numbers even."))
#+end_src

#+RESULTS:
: 
: "All numbers even."

~thereis~ 節は <test-form> が真になることがあるかを調べるのに使う。ループしている要素の中に、テスト式にかけて ~非NIL~ の値を返すものがあった時は、その値を返してループを終了する。何も起きずにループが完了してしまった場合、デフォルトの戻り値である ~NIL~ を返す。
#+begin_src lisp :results output
  (dbg (loop for char across "abc123" thereis (digit-char-p char)))
  (dbg (loop for char across "abcdef" thereis (digit-char-p char)))
#+end_src

#+RESULTS:
: (LOOP FOR CHAR ACROSS "abc123"
:       THEREIS (DIGIT-CHAR-P CHAR)) => 1
: (LOOP FOR CHAR ACROSS "abcdef"
:       THEREIS (DIGIT-CHAR-P CHAR)) => NIL

** ループのまとめ
以下のルールに従う限り、いままでに出てきた各節を自由に組み合わせることができる。
1. ~named~ は先頭に書く
2. ~initially, with, for, repeat~ は、 ~named~ のすぐ後に置く
3. 本体となる節 (条件実行節・無条件実行節・累積節・終了条件節) をその次に置く
4. 最後の ~finally~ 節を置く


LOOPマクロは以下のように動作するコードへと展開される。
1. ~with~ や ~for~ で宣言されたローカル変数と、累積節で暗黙的に作られた変数を初期化する。ループ内に出てきた順番で、初期値のフォームを評価する。
2. ~initially~ 前処理部のフォームを、出てきた順番で評価する。
3. ループの本体部の実行を繰り返す
4. ~finally~ 後処理部のフォームを、出てきた順番で実行する。
   
